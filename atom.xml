<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老根&#39;s Blog</title>
  
  <subtitle>Stay hungry, Stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maslow.github.io/"/>
  <updated>2018-11-27T04:17:15.872Z</updated>
  <id>http://maslow.github.io/</id>
  
  <author>
    <name>Maslow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js 源码分析 - 前言</title>
    <link href="http://maslow.github.io/2018/11/24/nodejs/nodejs-src-analysis/index/"/>
    <id>http://maslow.github.io/2018/11/24/nodejs/nodejs-src-analysis/index/</id>
    <published>2018-11-24T08:30:15.000Z</published>
    <updated>2018-11-27T04:17:15.872Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两年先后两次读过 Node.js 源码，但是每次都懒于记录，过几个月就忘记了，这次把疏理过程记录下来，免得以后再费时间从头看。</p></blockquote><h3 id="适合什么样的读者"><a href="#适合什么样的读者" class="headerlink" title="适合什么样的读者"></a>适合什么样的读者</h3><pre><code>- 你需要熟悉 C/C++- 你需要熟悉 Node.js，理解异步编程及原理</code></pre><a id="more"></a><h3 id="分析方式"><a href="#分析方式" class="headerlink" title="分析方式"></a>分析方式</h3><p>根据执行流程，直接从 main 函数开始走， 然后再单独分析具体模块。</p><p>疏理执行逻辑是这次分析的重点。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>V8 Embedding:</p><ul><li><a href="/2018/03/25/v8/compile-v8/" title="Javascript Engine V8 Embedding - 编译">Javascript Engine V8 Embedding - 编译</a></li><li><a href="/2018/03/26/v8/v8-embedding-hello-world/" title="Javascript Engine V8 Embedding - Hello World 讲解">Javascript Engine V8 Embedding - Hello World 讲解</a></li></ul><blockquote><p>持续更新中</p></blockquote><p>Node.js:</p><blockquote><p>TODO</p></blockquote><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li><p>Libuv 官网 User Guide 很友好：<a href="http://docs.libuv.org/en/v1.x/guide.html" target="_blank" rel="noopener">http://docs.libuv.org/en/v1.x/guide.html</a></p></li><li><p>Node.js 源码：<a href="https://github.com/nodejs/node" target="_blank" rel="noopener">https://github.com/nodejs/node</a></p></li><li><p>Node.js 源码构建：<a href="https://github.com/nodejs/node/blob/master/BUILDING" target="_blank" rel="noopener">https://github.com/nodejs/node/blob/master/BUILDING</a>.</p></li><li><p>V8 构建：<a href="https://v8.dev/docs/build" target="_blank" rel="noopener">https://v8.dev/docs/build</a></p></li><li><p>V8 Embedding: <a href="https://v8.dev/docs/embed" target="_blank" rel="noopener">https://v8.dev/docs/embed</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这两年先后两次读过 Node.js 源码，但是每次都懒于记录，过几个月就忘记了，这次把疏理过程记录下来，免得以后再费时间从头看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;适合什么样的读者&quot;&gt;&lt;a href=&quot;#适合什么样的读者&quot; class=&quot;headerlink&quot; title=&quot;适合什么样的读者&quot;&gt;&lt;/a&gt;适合什么样的读者&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- 你需要熟悉 C/C++
- 你需要熟悉 Node.js，理解异步编程及原理
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Node.js 源码分析" scheme="http://maslow.github.io/categories/Node-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Node.js" scheme="http://maslow.github.io/tags/Node-js/"/>
    
      <category term="Node.js 源码分析" scheme="http://maslow.github.io/tags/Node-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="源码分析" scheme="http://maslow.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>动手写一个简单的 Promise.js</title>
    <link href="http://maslow.github.io/2018/11/24/javascript/diy-simple-promise-js/"/>
    <id>http://maslow.github.io/2018/11/24/javascript/diy-simple-promise-js/</id>
    <published>2018-11-23T18:07:14.000Z</published>
    <updated>2018-11-23T19:00:16.701Z</updated>
    
    <content type="html"><![CDATA[<p>初学 <code>Node.js</code> 的朋友总会耗一番周折去理解 <code>Promise</code>，这里给出一个最简单的 <code>Promise</code> 实现，以帮助对 <code>Promise</code> 还有疑惑的同学彻底理解其实现原理。</p><a id="more"></a><blockquote><p>这个代码应该是三年前我刚接触 <code>Node.js</code> 的时候写的了，当时也是 Google 不少关于 <code>Promise</code> 的文章，现在已经不记得相关链接了。</p></blockquote><blockquote><p>这个并不是完整的 <code>Promise</code> 逻辑，旨在理解 <code>Promise</code> 的实现原理，由于过了太久，我就直接贴出来代码不做解释说明了。如果先前有用过 <code>Promise</code> 的话，应该还是较容易理解的； 若是初接触，这个逻辑还是有点绕，先去其它地方了解 Promse 的用法，再多花点时间去理一理这段代码，是值得的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    self.state = <span class="string">'PENDING'</span></span><br><span class="line">    self.onFulfilled = <span class="literal">null</span></span><br><span class="line">    self.onRejected = <span class="literal">null</span></span><br><span class="line">    self.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            that.onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> ret = onResolved ? onResolved(val) : val;</span><br><span class="line">                <span class="keyword">if</span> (ret &amp;&amp; ret.then) &#123;</span><br><span class="line">                    ret.then(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                        resolve(val)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    resolve(ret);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            that.onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> ret = onRejected ? onRejected(val) : val;</span><br><span class="line">                reject(ret);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    fn &amp;&amp; fn(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.state === <span class="string">'PENDING'</span>) &#123;</span><br><span class="line">            self.state = <span class="string">'FULFILLED'</span>;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                self.onFulfilled &amp;&amp; self.onFulfilled(result);</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.state === <span class="string">'PENDING'</span>) &#123;</span><br><span class="line">            self.state = <span class="string">'REJECTED'</span>;</span><br><span class="line">            self.onRejected &amp;&amp; self.onRejected(reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(t)</span><br><span class="line">            resolve(t)</span><br><span class="line">        &#125;, t)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> sleep(data + <span class="number">1</span>))</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> sleep(data + <span class="number">1</span>))</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> sleep(data + <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学 &lt;code&gt;Node.js&lt;/code&gt; 的朋友总会耗一番周折去理解 &lt;code&gt;Promise&lt;/code&gt;，这里给出一个最简单的 &lt;code&gt;Promise&lt;/code&gt; 实现，以帮助对 &lt;code&gt;Promise&lt;/code&gt; 还有疑惑的同学彻底理解其实现原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://maslow.github.io/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="http://maslow.github.io/tags/javascript/"/>
    
      <category term="promise" scheme="http://maslow.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>GitLab CI 示例：构建 &amp; 测试 Node.js 应用</title>
    <link href="http://maslow.github.io/2018/11/24/gitlab-ci/example-node-js/"/>
    <id>http://maslow.github.io/2018/11/24/gitlab-ci/example-node-js/</id>
    <published>2018-11-23T16:18:13.000Z</published>
    <updated>2018-11-23T19:11:53.509Z</updated>
    
    <content type="html"><![CDATA[<p>通过解释说明一个简单的 Node.js 应用的 <code>Pipeline</code> 示例来介绍 GitLab CI 的工作方式和使用。</p><p>其中会重点介绍 GitLab CI 的执行过程，<code>Stage</code> <code>Job</code> 等基础概念，以及缓存策略。<br><a id="more"></a></p><h2 id="示例定义"><a href="#示例定义" class="headerlink" title="示例定义"></a>示例定义</h2><p>下面是一个简单的 Node.js 应用的 pipeline 定义：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .gitlab-ci.yml</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build_job:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">node:10</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">version</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test_job:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">node:10</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br></pre></td></tr></table></figure></p><h2 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明"></a>解释说明</h2><p>逐一介绍一下这几个字段：</p><h3 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>stage 定义了 pipeline 的执行步骤，也就是说 stages 是有序执行的。每个 stages 可包括多个 Job，Job 才是 CI Runner 要执行的任务。</p><p>上面的 pipeline 包括 build 和 test 两个步骤，先执行完所有 build 阶段的 Job，才会执行 test 阶段的 Job。</p><p>如果 build 阶段的 Job 执行失败了，则整个 pipeline 失败并中断执行，不会继续执行 test stage 了。</p><p>下面就来介绍什么是 Job.</p><h3 id="build-job"><a href="#build-job" class="headerlink" title="build_job"></a>build_job</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build_job:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">node:10</span> </span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">version</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure><p><code>build_job</code> 是 Job 的名称，可以自由定义；</p><p><code>stage</code> 字段指定该 Job 属于 <code>build</code> 阶段的；</p><p><code>script</code> 就是自定义的构建脚本了，这里就是简单的 <code>npm install</code>；</p><p><code>image</code> 这个是指定 <code>script</code> 脚本的执行环境，它的值应该是一个 Docker 镜像。</p><p>Runner 开始执行这个 Job 时，首先会 pull 项目的最新代码，然后基于这个镜像启动一个容器并把代码挂载到容器里，最后在这个容器里面执行 <code>script</code> 定义的脚本。因为我们这里使用的是 node:10 作为作业的镜像，所以在 <code>script</code> 里才可以直接用 npm。</p><h3 id="test-job"><a href="#test-job" class="headerlink" title="test_job"></a>test_job</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">test_job:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">node:10</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p><code>test_job</code> 同样是一个 Job，它属于 <code>test stage</code>，在上面的 <code>stages</code> 定义中 <code>test</code> 是在 <code>build</code> 之后的，所以它会等所有 <code>build</code> 阶段的 Job 执行完之后才会被执行。</p><blockquote><p>重点来了：每个 Job 是独立执行的，互相隔离的。 Runner 在执行 <code>test_job</code> 的时候，会重新 pull 应用的最新代码，然后启动一个新容器并挂载代码，再在里面执行 script 脚本。 </p></blockquote><p>这就会导致一个问题： 在 <code>test_job</code> 中我们并没有执行 <code>npm install</code> 就直接执行了 <code>npm run test</code>，理论上会是报错的！</p><p>这就要介绍最后一个未介绍的字段 <code>cache</code>.</p><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules/</span></span><br></pre></td></tr></table></figure><p><code>cache</code> 是 pipeline 中定义 Job 之间的缓存的；</p><p>我们这里定义的 <code>cache</code> 是全局的，即作用于所有 Job 的；</p><p><code>paths</code> 定义需要缓存的目录，若需要，你可以指定多个；</p><p>缓存的逻辑是这样的：</p><pre><code>- 执行 build_job 时会检查之前无有缓存- 如果有缓存就下载到 `paths` 指定的缓存目录，无则忽略- build_job 执行结束之前，会重新把缓存目录缓存起来- test_job 执行之前，同样检查有无缓存，有则下载</code></pre><p>所以，test_job 的 script 中没有执行 <code>npm install</code> 是因为我们将 <code>node_modules</code> 目录缓存了。 </p><p>缓存是提高 Job 执行效率的策略，不仅仅是多个 Job 之间； </p><p>同一个 Job 在多次 pipeline 中也会共用缓存，意思是：</p><pre><code>- build_job 第一次运行时并没有缓存- 下次 pipeline 执行时，npm install 就会基于缓存的 node_modules 更新，而不是全量下载了</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个示例，基本就了解 GitLab CI 的工作过程和定义方式了；</p><p>其中缓存策略是非常常用的，这里使用的是全局缓存，还可以指定某个 Job 特有有缓存策略。</p><p>想进一步了解缓存，请查看官方文档关于缓存的详细说明:<br><a href="https://docs.gitlab.com/ee/ci/yaml/README.html#cache" target="_blank" rel="noopener">https://docs.gitlab.com/ee/ci/yaml/README.html#cache</a></p><p>这个简单的示例，只是展示了 Node.js 应用的构建和测试，一个更完整的 CI 流程通常还会包括 <code>部署(deploy)</code>，接下来会继续通过示例讲解使用 GitLab CI 的更多使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过解释说明一个简单的 Node.js 应用的 &lt;code&gt;Pipeline&lt;/code&gt; 示例来介绍 GitLab CI 的工作方式和使用。&lt;/p&gt;
&lt;p&gt;其中会重点介绍 GitLab CI 的执行过程，&lt;code&gt;Stage&lt;/code&gt; &lt;code&gt;Job&lt;/code&gt; 等基础概念，以及缓存策略。&lt;br&gt;
    
    </summary>
    
      <category term="GitLab CI/CD" scheme="http://maslow.github.io/categories/GitLab-CI-CD/"/>
    
      <category term="GitLab CI Examples" scheme="http://maslow.github.io/categories/GitLab-CI-CD/GitLab-CI-Examples/"/>
    
    
      <category term="gitlab" scheme="http://maslow.github.io/tags/gitlab/"/>
    
      <category term="gitlab-ci" scheme="http://maslow.github.io/tags/gitlab-ci/"/>
    
      <category term="CI/CD" scheme="http://maslow.github.io/tags/CI-CD/"/>
    
      <category term="DevOps" scheme="http://maslow.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>GitLab CI 基本介绍</title>
    <link href="http://maslow.github.io/2018/11/09/gitlab-ci/index/"/>
    <id>http://maslow.github.io/2018/11/09/gitlab-ci/index/</id>
    <published>2018-11-08T16:03:53.000Z</published>
    <updated>2018-11-23T19:03:06.360Z</updated>
    
    <content type="html"><![CDATA[<img src="https://docs.gitlab.com/ee/ci/img/cicd_pipeline_infograph.png"><blockquote><p>这篇基本介绍只介绍 GitLab CI，不会写具体的使用细节，旨在让新接触 GitLab CI 的同学先对它有个基本的认识，直接看官网文档可能需要多花点时间才能理清一些概念。</p></blockquote><blockquote><p>GitLab CI 的设计很灵活，有多种使用方案，我在接下来会针对最常用的几种情况写一系列包括实现细节步骤的文章。</p></blockquote><a id="more"></a><h3 id="前置需求"><a href="#前置需求" class="headerlink" title="前置需求"></a>前置需求</h3><p>当前有 3 台服务器 develop, staging, production 分别对应代码仓库上的三个分支：develop, staging, master。</p><p>要求 push 代码到仓库时会触发 CI 的执行：</p><pre><code>1. build app2. testing app3. deploy to server</code></pre><p>代码 push 到哪个分支，就把项目部署到相应的服务器上。</p><h3 id="GitLab-CI-的重要概念"><a href="#GitLab-CI-的重要概念" class="headerlink" title="GitLab CI 的重要概念"></a>GitLab CI 的重要概念</h3><p>要理解 GitLab CI 的工作方式，必须要理解两个概念：</p><pre><code>- Pipeline- Runner</code></pre><p>上面说的 CI 执行过程就是 <code>pipeline</code>，它定义了项目的构建、测试、部署等的执行过程。</p><p>我们需要在每个项目上定义一个 <code>pipeline</code>。</p><p>定义一个 <code>pipeline</code> 就是在项目代码根目录创建文件：<code>.gitlab-ci.yml</code>.</p><p>定义好 <code>pipeline</code> 后，GitLab CI 会读取并执行这个 <code>pipeline</code>，执行的程序叫做 <code>Runner</code>。</p><p><code>Runner</code> 是负责执行 <code>pipeline</code> 的程序。</p><p>通常 <code>Runner</code> 需要我们自己安装并运行在自己的服务器上，当然也可以使用 gitlab.com 官方提供的免费的 Shared Runner 服务。</p><h3 id="GitLab-CI-的工作方式"><a href="#GitLab-CI-的工作方式" class="headerlink" title="GitLab CI 的工作方式"></a>GitLab CI 的工作方式</h3><ul><li><p>Pipeline 的触发<br>当开发者 Push 代码到某个分支时，如果我们定义了 Pipeline，也就是代码根目录中有 <code>.gitlab-ci.yml</code> 文件，GitLab 会自动触发 Pipeline 的执行。</p></li><li><p>Pipeline 的执行<br>Pipeline 执行时，首先会 pull 下来被触发分支的代码，然后执行你在 pipline 中定义的 Job，Job 是你指定的一些 shell scripts，它就是你构建项目的逻辑。</p></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>简单介绍一下 GitLab CI 的几个重要概念，接下来会通过实例来详细讲解 GitLab CI 的使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://docs.gitlab.com/ee/ci/img/cicd_pipeline_infograph.png&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇基本介绍只介绍 GitLab CI，不会写具体的使用细节，旨在让新接触 GitLab CI 的同学先对它有个基本的认识，直接看官网文档可能需要多花点时间才能理清一些概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;GitLab CI 的设计很灵活，有多种使用方案，我在接下来会针对最常用的几种情况写一系列包括实现细节步骤的文章。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="GitLab CI/CD" scheme="http://maslow.github.io/categories/GitLab-CI-CD/"/>
    
      <category term="GitLab CI 基本介绍" scheme="http://maslow.github.io/categories/GitLab-CI-CD/GitLab-CI-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="gitlab" scheme="http://maslow.github.io/tags/gitlab/"/>
    
      <category term="gitlab-ci" scheme="http://maslow.github.io/tags/gitlab-ci/"/>
    
      <category term="CI/CD" scheme="http://maslow.github.io/tags/CI-CD/"/>
    
      <category term="DevOps" scheme="http://maslow.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Engine V8 Embedding - Hello World 讲解</title>
    <link href="http://maslow.github.io/2018/03/26/v8/v8-embedding-hello-world/"/>
    <id>http://maslow.github.io/2018/03/26/v8/v8-embedding-hello-world/</id>
    <published>2018-03-26T15:47:14.000Z</published>
    <updated>2018-11-27T04:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>通过一个 Hello World 示例来介绍 V8 的几个重要概念。</p><p>这个示例代码是基于 V8 (7.1) 的，要编译这个示例请查看 <a href="/2018/03/25/v8/compile-v8/" title="Javascript Engine V8 Embedding - 编译">Javascript Engine V8 Embedding - 编译</a></p><a id="more"></a><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/libplatform/libplatform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/v8.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化 V8</span></span><br><span class="line">  v8::V8::InitializeICUDefaultLocation(argv[<span class="number">0</span>]);</span><br><span class="line">  v8::V8::InitializeExternalStartupData(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform();</span><br><span class="line">  v8::V8::InitializePlatform(platform.get());</span><br><span class="line">  v8::V8::Initialize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 Isolate 实例, 它代表一个 JS VM 实例</span></span><br><span class="line">  v8::Isolate::CreateParams create_params;</span><br><span class="line">  create_params.array_buffer_allocator =</span><br><span class="line">      v8::ArrayBuffer::Allocator::NewDefaultAllocator();</span><br><span class="line"></span><br><span class="line">  v8::Isolate* isolate = v8::Isolate::New(create_params);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 使用 isolate</span></span><br><span class="line">    v8::Isolate::<span class="function">Scope <span class="title">isolate_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 HandleScope，用于管理 Handle 的生命周期 </span></span><br><span class="line">    v8::<span class="function">HandleScope <span class="title">handle_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Context，它是 javascript 代码执行的环境上下文对象</span></span><br><span class="line">    v8::Local&lt;v8::Context&gt; context = v8::Context::New(isolate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入 or 使用 context</span></span><br><span class="line">    v8::Context::<span class="function">Scope <span class="title">context_scope</span><span class="params">(context)</span></span>;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 定义 JS 代码字符串</span></span><br><span class="line">      v8::Local&lt;v8::String&gt; source =</span><br><span class="line">          v8::String::NewFromUtf8(isolate, <span class="string">"'Hello' + ', World!'"</span>,</span><br><span class="line">                                  v8::NewStringType::kNormal).ToLocalChecked();</span><br><span class="line">      <span class="comment">// 编译 JS 代码</span></span><br><span class="line">      v8::Local&lt;v8::Script&gt; script =</span><br><span class="line">          v8::Script::Compile(context, source).ToLocalChecked();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 运行 JS 代码，并获取结果</span></span><br><span class="line">      v8::Local&lt;v8::Value&gt; result = script-&gt;Run(context).ToLocalChecked();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将运行结果转换为 UTF8 字符串，并打印</span></span><br><span class="line">      v8::String::<span class="function">Utf8Value <span class="title">utf8</span><span class="params">(isolate, result)</span></span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *utf8);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放 V8 相关资源</span></span><br><span class="line">  isolate-&gt;Dispose();</span><br><span class="line">  v8::V8::Dispose();</span><br><span class="line">  v8::V8::ShutdownPlatform();</span><br><span class="line">  <span class="keyword">delete</span> create_params.array_buffer_allocator;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="V8-重要概念"><a href="#V8-重要概念" class="headerlink" title="V8 重要概念"></a>V8 重要概念</h3><h4 id="Isolate"><a href="#Isolate" class="headerlink" title="Isolate"></a>Isolate</h4><p>一个 Isolate 就是一个 VM 实例，它有自己独立的 Heap。</p><h4 id="Handle"><a href="#Handle" class="headerlink" title="Handle"></a>Handle</h4><p>一个 <code>Handle</code> 就是对一个 V8 object 的引用， V8 objects 都是分配在 Heap 中的，所有 V8 objects 都需要通过一个<code>Handle</code> 引用来访问，才能保证 V8 garbage collector 能工作。</p><p><code>Handle</code> 又分 <code>Local</code>（局部） 和 <code>Persistent</code>（全局）两种。 </p><p><code>Local Handle</code> 的生命周期 使用 <code>HandleScope</code> 来管理，而 <code>Persistent</code> 是全局的 <code>Handle</code>， 需要通过 <code>Persistent::New()</code> 和 <code>Persistent::Release()</code> 来创建和释放。 </p><h4 id="Handle-Scope"><a href="#Handle-Scope" class="headerlink" title="Handle Scope"></a>Handle Scope</h4><p>一个 <code>Handle Scope</code> 可以理解为用来批量管理 <code>Handle</code> 的容器，这样我们就不用一个个的去释放 <code>Handle</code>，只要把它们的 <code>Handle Scope</code> 释放掉就可以了。</p><p><code>Handle Scope</code> 相当于提供了 <code>Handle Stack</code> 机制来管理 Handles，当一个 <code>Handle Scope</code> 本身被释放的时候，会从 <code>Handle Stack</code> 上弹出所有基于它的 <code>Local Handles。</code></p><p>注意：这个 <code>Handle Stack</code> 并不是 <code>C++ 调用栈</code>， <code>Handle Scope</code> 是在 <code>C++ 调用栈`</code>中的分配的，Handle Scope<code>必须创建在栈上，不能用</code>new` 创建！</p><img src="https://v8.dev/_img/docs/embed/local-persist-handles-review.png"><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p><code>Context</code> 是 javascript 代码的执行环境；</p><p>想像一下，你有多个不相关的 js 代码要运行，这些代码运行的过程中可能会修改 V8 全局的一些状态，就需要给他们指定不同的 <code>context</code> 才能相互独立的隔离运行。</p><p>另外，我们可以为一个 <code>context</code> 设置预定义的全局属性，这个属性可以是 C++ 写的对象或方法，这样在 js 环境中，就能够调用 C++ 对象了，相当于扩充了 js 的能力。</p><p>比如，<code>Node.js</code> 中的 <code>process</code> 对象，就是一个预定义到 <code>context</code> 的对象，所以在 <code>Node.js</code> 中可以直接使用。同样的，浏览器中的 <code>window</code> <code>document</code> 等全局对象，也是预定义到 <code>context</code> 上的。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>Getting started with embedding V8: <a href="https://v8.dev/docs/embed#advanced-guide" target="_blank" rel="noopener">https://v8.dev/docs/embed#advanced-guide</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过一个 Hello World 示例来介绍 V8 的几个重要概念。&lt;/p&gt;
&lt;p&gt;这个示例代码是基于 V8 (7.1) 的，要编译这个示例请查看 &lt;a href=&quot;/2018/03/25/v8/compile-v8/&quot; title=&quot;Javascript Engine V8 Embedding - 编译&quot;&gt;Javascript Engine V8 Embedding - 编译&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript Engine V8" scheme="http://maslow.github.io/categories/Javascript-Engine-V8/"/>
    
    
      <category term="Node.js" scheme="http://maslow.github.io/tags/Node-js/"/>
    
      <category term="javascript" scheme="http://maslow.github.io/tags/javascript/"/>
    
      <category term="V8" scheme="http://maslow.github.io/tags/V8/"/>
    
      <category term="C/C++" scheme="http://maslow.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Engine V8 Embedding - 编译</title>
    <link href="http://maslow.github.io/2018/03/25/v8/compile-v8/"/>
    <id>http://maslow.github.io/2018/03/25/v8/compile-v8/</id>
    <published>2018-03-25T15:47:14.000Z</published>
    <updated>2018-11-27T02:47:20.705Z</updated>
    
    <content type="html"><![CDATA[<p>直接 git pull V8 的代码是不行的，需要使用 Google 提供的 depot_tools 工具包来获对代码并配置。</p><p>需要翻墙，下载和编译的耗时都很长，分别视你的网络情况和机器配置而定。</p><p>为了屏蔽掉不同系统的差异，直接使用 Docker 容器环境来编译。</p><a id="more"></a><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu bash  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装必要的工具</span></span><br><span class="line">apt update</span><br><span class="line">apt install -y git curl python xz-utils lbzip2 lsb-release lsb-core sudo vim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Google 开发工具包</span></span><br><span class="line"><span class="comment"># see more: https://v8.dev/docs/source-code#using-git</span></span><br><span class="line"><span class="built_in">cd</span> /root &amp;&amp; git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/root/depot_tools</span><br><span class="line"></span><br><span class="line">gclient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 v8 代码</span></span><br><span class="line">fetch v8</span><br><span class="line"><span class="built_in">cd</span> v8</span><br><span class="line"></span><br><span class="line">git checkout refs/tags/7.1.11 -b sample -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步依赖</span></span><br><span class="line">gclient sync</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个构建配置</span></span><br><span class="line">tools/dev/v8gen.py x64.release.sample</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始构建 v8 静态库</span></span><br><span class="line"><span class="comment"># 构建耗时较长，视你的机器配置而定</span></span><br><span class="line">ninja -C out.gn/x64.release.sample v8_monolith</span><br></pre></td></tr></table></figure><h3 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h3><p>等上面 v8 编译完成后，就可以使用编译好的静态库了，我们编译一下 v8 提供的 hello-world 示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">g++ -I. -Iinclude samples/hello-world.cc -o hello_world -lv8_monolith -Lout.gn/x64.release.sample/obj/ -pthread -std=c++0x</span><br><span class="line"> </span><br><span class="line"><span class="comment"># icu 数据文件，运行时需要</span></span><br><span class="line">cp out.gn/x64.release.sample/icudtl.dat .</span><br><span class="line"></span><br><span class="line">./hello_world</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://v8.dev/docs/embed" target="_blank" rel="noopener">https://v8.dev/docs/embed</a></p><p><a href="https://v8.dev/docs/source-code#using-git" target="_blank" rel="noopener">https://v8.dev/docs/source-code#using-git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;直接 git pull V8 的代码是不行的，需要使用 Google 提供的 depot_tools 工具包来获对代码并配置。&lt;/p&gt;
&lt;p&gt;需要翻墙，下载和编译的耗时都很长，分别视你的网络情况和机器配置而定。&lt;/p&gt;
&lt;p&gt;为了屏蔽掉不同系统的差异，直接使用 Docker 容器环境来编译。&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript Engine V8" scheme="http://maslow.github.io/categories/Javascript-Engine-V8/"/>
    
    
      <category term="Node.js" scheme="http://maslow.github.io/tags/Node-js/"/>
    
      <category term="javascript" scheme="http://maslow.github.io/tags/javascript/"/>
    
      <category term="V8" scheme="http://maslow.github.io/tags/V8/"/>
    
      <category term="C/C++" scheme="http://maslow.github.io/tags/C-C/"/>
    
  </entry>
  
</feed>
