{"meta":{"title":"老根's Blog","subtitle":"Stay hungry, Stay foolish","description":null,"author":"Maslow","url":"http://maslow.github.io"},"pages":[{"title":"","date":"2018-11-03T16:58:01.395Z","updated":"2018-11-03T16:58:01.395Z","comments":false,"path":"categories/index.html","permalink":"http://maslow.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-03T16:57:58.708Z","updated":"2018-11-03T16:57:58.708Z","comments":false,"path":"tags/index.html","permalink":"http://maslow.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-03T19:53:56.612Z","updated":"2018-11-03T19:53:56.611Z","comments":true,"path":"downloads/code/app.js","permalink":"http://maslow.github.io/downloads/code/app.js","excerpt":"","text":"const fs = require('fs')"}],"posts":[{"title":"Node.js 源码分析 - 前言","slug":"nodejs/nodejs-src-analysis/index","date":"2018-11-24T08:30:15.000Z","updated":"2018-11-27T04:17:15.872Z","comments":true,"path":"2018/11/24/nodejs/nodejs-src-analysis/index/","link":"","permalink":"http://maslow.github.io/2018/11/24/nodejs/nodejs-src-analysis/index/","excerpt":"这两年先后两次读过 Node.js 源码，但是每次都懒于记录，过几个月就忘记了，这次把疏理过程记录下来，免得以后再费时间从头看。 适合什么样的读者- 你需要熟悉 C/C++ - 你需要熟悉 Node.js，理解异步编程及原理","text":"这两年先后两次读过 Node.js 源码，但是每次都懒于记录，过几个月就忘记了，这次把疏理过程记录下来，免得以后再费时间从头看。 适合什么样的读者- 你需要熟悉 C/C++ - 你需要熟悉 Node.js，理解异步编程及原理 分析方式根据执行流程，直接从 main 函数开始走， 然后再单独分析具体模块。 疏理执行逻辑是这次分析的重点。 目录V8 Embedding: Javascript Engine V8 Embedding - 编译 Javascript Engine V8 Embedding - Hello World 讲解 持续更新中 Node.js: TODO 相关资料 Libuv 官网 User Guide 很友好：http://docs.libuv.org/en/v1.x/guide.html Node.js 源码：https://github.com/nodejs/node Node.js 源码构建：https://github.com/nodejs/node/blob/master/BUILDING. V8 构建：https://v8.dev/docs/build V8 Embedding: https://v8.dev/docs/embed","categories":[{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"http://maslow.github.io/categories/Node-js-源码分析/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://maslow.github.io/tags/Node-js/"},{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"http://maslow.github.io/tags/Node-js-源码分析/"},{"name":"源码分析","slug":"源码分析","permalink":"http://maslow.github.io/tags/源码分析/"}]},{"title":"动手写一个简单的 Promise.js","slug":"javascript/diy-simple-promise-js","date":"2018-11-23T18:07:14.000Z","updated":"2018-11-23T19:00:16.701Z","comments":true,"path":"2018/11/24/javascript/diy-simple-promise-js/","link":"","permalink":"http://maslow.github.io/2018/11/24/javascript/diy-simple-promise-js/","excerpt":"初学 Node.js 的朋友总会耗一番周折去理解 Promise，这里给出一个最简单的 Promise 实现，以帮助对 Promise 还有疑惑的同学彻底理解其实现原理。","text":"初学 Node.js 的朋友总会耗一番周折去理解 Promise，这里给出一个最简单的 Promise 实现，以帮助对 Promise 还有疑惑的同学彻底理解其实现原理。 这个代码应该是三年前我刚接触 Node.js 的时候写的了，当时也是 Google 不少关于 Promise 的文章，现在已经不记得相关链接了。 这个并不是完整的 Promise 逻辑，旨在理解 Promise 的实现原理，由于过了太久，我就直接贴出来代码不做解释说明了。如果先前有用过 Promise 的话，应该还是较容易理解的； 若是初接触，这个逻辑还是有点绕，先去其它地方了解 Promse 的用法，再多花点时间去理一理这段代码，是值得的。 12345678910111213141516171819202122232425262728293031323334353637383940// Promisefunction Promise(fn) &#123; var self = this self.state = 'PENDING' self.onFulfilled = null self.onRejected = null self.then = function (onResolved, onRejected) &#123; var that = this; return new Promise(function (resolve, reject) &#123; that.onFulfilled = function (val) &#123; var ret = onResolved ? onResolved(val) : val; if (ret &amp;&amp; ret.then) &#123; ret.then(function (val) &#123; resolve(val) &#125;) &#125; else &#123; resolve(ret); &#125; &#125;; that.onRejected = function (val) &#123; var ret = onRejected ? onRejected(val) : val; reject(ret); &#125;; &#125;); &#125; fn &amp;&amp; fn(function (result) &#123; if (self.state === 'PENDING') &#123; self.state = 'FULFILLED'; setTimeout(function()&#123; self.onFulfilled &amp;&amp; self.onFulfilled(result); &#125;,0) &#125; &#125;, function (reason) &#123; if (self.state === 'PENDING') &#123; self.state = 'REJECTED'; self.onRejected &amp;&amp; self.onRejected(reason); &#125; &#125;);&#125; 使用示例：12345678910111213function sleep(t) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function () &#123; console.log(t) resolve(t) &#125;, t) &#125;)&#125;sleep(1000) .then(data =&gt; sleep(data + 1)) .then(data =&gt; sleep(data + 1)) .then(data =&gt; sleep(data + 1))","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://maslow.github.io/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://maslow.github.io/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"http://maslow.github.io/tags/promise/"}]},{"title":"GitLab CI 示例：构建 & 测试 Node.js 应用","slug":"gitlab-ci/example-node-js","date":"2018-11-23T16:18:13.000Z","updated":"2018-11-23T19:11:53.509Z","comments":true,"path":"2018/11/24/gitlab-ci/example-node-js/","link":"","permalink":"http://maslow.github.io/2018/11/24/gitlab-ci/example-node-js/","excerpt":"通过解释说明一个简单的 Node.js 应用的 Pipeline 示例来介绍 GitLab CI 的工作方式和使用。 其中会重点介绍 GitLab CI 的执行过程，Stage Job 等基础概念，以及缓存策略。","text":"通过解释说明一个简单的 Node.js 应用的 Pipeline 示例来介绍 GitLab CI 的工作方式和使用。 其中会重点介绍 GitLab CI 的执行过程，Stage Job 等基础概念，以及缓存策略。 示例定义下面是一个简单的 Node.js 应用的 pipeline 定义：123456789101112131415161718192021# .gitlab-ci.ymlstages: - build - testcache: paths: - node_modules/build_job: image: node:10 stage: build script: - npm version - npm installtest_job: image: node:10 stage: test script: - npm run test 解释说明逐一介绍一下这几个字段： stages123stages: - build - test stage 定义了 pipeline 的执行步骤，也就是说 stages 是有序执行的。每个 stages 可包括多个 Job，Job 才是 CI Runner 要执行的任务。 上面的 pipeline 包括 build 和 test 两个步骤，先执行完所有 build 阶段的 Job，才会执行 test 阶段的 Job。 如果 build 阶段的 Job 执行失败了，则整个 pipeline 失败并中断执行，不会继续执行 test stage 了。 下面就来介绍什么是 Job. build_job123456build_job: image: node:10 stage: build script: - npm version - npm install build_job 是 Job 的名称，可以自由定义； stage 字段指定该 Job 属于 build 阶段的； script 就是自定义的构建脚本了，这里就是简单的 npm install； image 这个是指定 script 脚本的执行环境，它的值应该是一个 Docker 镜像。 Runner 开始执行这个 Job 时，首先会 pull 项目的最新代码，然后基于这个镜像启动一个容器并把代码挂载到容器里，最后在这个容器里面执行 script 定义的脚本。因为我们这里使用的是 node:10 作为作业的镜像，所以在 script 里才可以直接用 npm。 test_job12345test_job: image: node:10 stage: test script: - npm run test test_job 同样是一个 Job，它属于 test stage，在上面的 stages 定义中 test 是在 build 之后的，所以它会等所有 build 阶段的 Job 执行完之后才会被执行。 重点来了：每个 Job 是独立执行的，互相隔离的。 Runner 在执行 test_job 的时候，会重新 pull 应用的最新代码，然后启动一个新容器并挂载代码，再在里面执行 script 脚本。 这就会导致一个问题： 在 test_job 中我们并没有执行 npm install 就直接执行了 npm run test，理论上会是报错的！ 这就要介绍最后一个未介绍的字段 cache. cache123cache: paths: - node_modules/ cache 是 pipeline 中定义 Job 之间的缓存的； 我们这里定义的 cache 是全局的，即作用于所有 Job 的； paths 定义需要缓存的目录，若需要，你可以指定多个； 缓存的逻辑是这样的： - 执行 build_job 时会检查之前无有缓存 - 如果有缓存就下载到 `paths` 指定的缓存目录，无则忽略 - build_job 执行结束之前，会重新把缓存目录缓存起来 - test_job 执行之前，同样检查有无缓存，有则下载 所以，test_job 的 script 中没有执行 npm install 是因为我们将 node_modules 目录缓存了。 缓存是提高 Job 执行效率的策略，不仅仅是多个 Job 之间； 同一个 Job 在多次 pipeline 中也会共用缓存，意思是： - build_job 第一次运行时并没有缓存 - 下次 pipeline 执行时，npm install 就会基于缓存的 node_modules 更新，而不是全量下载了 总结通过这个示例，基本就了解 GitLab CI 的工作过程和定义方式了； 其中缓存策略是非常常用的，这里使用的是全局缓存，还可以指定某个 Job 特有有缓存策略。 想进一步了解缓存，请查看官方文档关于缓存的详细说明:https://docs.gitlab.com/ee/ci/yaml/README.html#cache 这个简单的示例，只是展示了 Node.js 应用的构建和测试，一个更完整的 CI 流程通常还会包括 部署(deploy)，接下来会继续通过示例讲解使用 GitLab CI 的更多使用。","categories":[{"name":"GitLab CI/CD","slug":"GitLab-CI-CD","permalink":"http://maslow.github.io/categories/GitLab-CI-CD/"},{"name":"GitLab CI Examples","slug":"GitLab-CI-CD/GitLab-CI-Examples","permalink":"http://maslow.github.io/categories/GitLab-CI-CD/GitLab-CI-Examples/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://maslow.github.io/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"http://maslow.github.io/tags/gitlab-ci/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://maslow.github.io/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","permalink":"http://maslow.github.io/tags/DevOps/"}]},{"title":"GitLab CI 基本介绍","slug":"gitlab-ci/index","date":"2018-11-08T16:03:53.000Z","updated":"2018-11-23T19:03:06.360Z","comments":true,"path":"2018/11/09/gitlab-ci/index/","link":"","permalink":"http://maslow.github.io/2018/11/09/gitlab-ci/index/","excerpt":"这篇基本介绍只介绍 GitLab CI，不会写具体的使用细节，旨在让新接触 GitLab CI 的同学先对它有个基本的认识，直接看官网文档可能需要多花点时间才能理清一些概念。 GitLab CI 的设计很灵活，有多种使用方案，我在接下来会针对最常用的几种情况写一系列包括实现细节步骤的文章。","text":"这篇基本介绍只介绍 GitLab CI，不会写具体的使用细节，旨在让新接触 GitLab CI 的同学先对它有个基本的认识，直接看官网文档可能需要多花点时间才能理清一些概念。 GitLab CI 的设计很灵活，有多种使用方案，我在接下来会针对最常用的几种情况写一系列包括实现细节步骤的文章。 前置需求当前有 3 台服务器 develop, staging, production 分别对应代码仓库上的三个分支：develop, staging, master。 要求 push 代码到仓库时会触发 CI 的执行： 1. build app 2. testing app 3. deploy to server 代码 push 到哪个分支，就把项目部署到相应的服务器上。 GitLab CI 的重要概念要理解 GitLab CI 的工作方式，必须要理解两个概念： - Pipeline - Runner 上面说的 CI 执行过程就是 pipeline，它定义了项目的构建、测试、部署等的执行过程。 我们需要在每个项目上定义一个 pipeline。 定义一个 pipeline 就是在项目代码根目录创建文件：.gitlab-ci.yml. 定义好 pipeline 后，GitLab CI 会读取并执行这个 pipeline，执行的程序叫做 Runner。 Runner 是负责执行 pipeline 的程序。 通常 Runner 需要我们自己安装并运行在自己的服务器上，当然也可以使用 gitlab.com 官方提供的免费的 Shared Runner 服务。 GitLab CI 的工作方式 Pipeline 的触发当开发者 Push 代码到某个分支时，如果我们定义了 Pipeline，也就是代码根目录中有 .gitlab-ci.yml 文件，GitLab 会自动触发 Pipeline 的执行。 Pipeline 的执行Pipeline 执行时，首先会 pull 下来被触发分支的代码，然后执行你在 pipline 中定义的 Job，Job 是你指定的一些 shell scripts，它就是你构建项目的逻辑。 小结简单介绍一下 GitLab CI 的几个重要概念，接下来会通过实例来详细讲解 GitLab CI 的使用。","categories":[{"name":"GitLab CI/CD","slug":"GitLab-CI-CD","permalink":"http://maslow.github.io/categories/GitLab-CI-CD/"},{"name":"GitLab CI 基本介绍","slug":"GitLab-CI-CD/GitLab-CI-基本介绍","permalink":"http://maslow.github.io/categories/GitLab-CI-CD/GitLab-CI-基本介绍/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://maslow.github.io/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"http://maslow.github.io/tags/gitlab-ci/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://maslow.github.io/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","permalink":"http://maslow.github.io/tags/DevOps/"}]},{"title":"Javascript Engine V8 Embedding - Hello World 讲解","slug":"v8/v8-embedding-hello-world","date":"2018-03-26T15:47:14.000Z","updated":"2018-11-27T04:16:47.903Z","comments":true,"path":"2018/03/26/v8/v8-embedding-hello-world/","link":"","permalink":"http://maslow.github.io/2018/03/26/v8/v8-embedding-hello-world/","excerpt":"通过一个 Hello World 示例来介绍 V8 的几个重要概念。 这个示例代码是基于 V8 (7.1) 的，要编译这个示例请查看 Javascript Engine V8 Embedding - 编译","text":"通过一个 Hello World 示例来介绍 V8 的几个重要概念。 这个示例代码是基于 V8 (7.1) 的，要编译这个示例请查看 Javascript Engine V8 Embedding - 编译 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include \"include/libplatform/libplatform.h\"#include \"include/v8.h\"int main(int argc, char* argv[]) &#123; // 初始化 V8 v8::V8::InitializeICUDefaultLocation(argv[0]); v8::V8::InitializeExternalStartupData(argv[0]); std::unique_ptr&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform(); v8::V8::InitializePlatform(platform.get()); v8::V8::Initialize(); // 创建一个 Isolate 实例, 它代表一个 JS VM 实例 v8::Isolate::CreateParams create_params; create_params.array_buffer_allocator = v8::ArrayBuffer::Allocator::NewDefaultAllocator(); v8::Isolate* isolate = v8::Isolate::New(create_params); &#123; // 使用 isolat\be v8::Isolate::Scope isolate_scope(isolate); // 创建一个 HandleScope，用于管理 Handle 的生命周期 v8::HandleScope handle_scope(isolate); // 创建 Context，它是 javascript 代码执行的环境上下文对象 v8::Local&lt;v8::Context&gt; context = v8::Context::New(isolate); // 进入 or 使用 context v8::Context::Scope context_scope(context); &#123; // 定义 JS 代码字符串 v8::Local&lt;v8::String&gt; source = v8::String::NewFromUtf8(isolate, \"'Hello' + ', World!'\", v8::NewStringType::kNormal).ToLocalChecked(); // 编译 JS 代码 v8::Local&lt;v8::Script&gt; script = v8::Script::Compile(context, source).ToLocalChecked(); // 运行 JS 代码，并获取结果 v8::Local&lt;v8::Value&gt; result = script-&gt;Run(context).ToLocalChecked(); // 将运行结果转换为 UTF8 字符串，并打印 v8::String::Utf8Value utf8(isolate, result); printf(\"%s\\n\", *utf8); &#125; &#125; // 释放 V8 相关资源 isolate-&gt;Dispose(); v8::V8::Dispose(); v8::V8::ShutdownPlatform(); delete create_params.array_buffer_allocator; return 0;&#125; V8 重要概念Isolate一个 Isolate 就是一个 VM 实例，它有自己独立的 Heap。 Handle一个 Handle 就是对一个 V8 object 的引用， V8 objects 都是分配在 Heap 中的，所有 V8 objects 都需要通过一个Handle 引用来访问，才能保证 V8 garbage collector 能工作。 Handle 又分 Local（局部） 和 Persistent（全局）两种。 Local Handle 的生命周期 使用 HandleScope 来管理，而 Persistent 是全局的 Handle， 需要通过 Persistent::New() 和 Persistent::Release() 来创建和释放。 Handle Scope一个 Handle Scope 可以理解为用来批量管理 Handle 的容器，这样我们就不用一个个的去释放 Handle，只要把它们的 Handle Scope 释放掉就可以了。 Handle Scope 相当于提供了 Handle Stack 机制来管理 Handles，当一个 Handle Scope 本身被释放的时候，会从 Handle Stack 上弹出所有基于它的 Local Handles。 注意：这个 Handle Stack 并不是 C++ 调用栈， Handle Scope 是在 C++ 调用栈`中的分配的，Handle Scope必须创建在栈上，不能用new` 创建！ ContextContext 是 javascript 代码的执行环境； 想像一下，你有多个不相关的 js 代码要运行，这些代码运行的过程中可能会修改 V8 全局的一些状态，就需要给他们指定不同的 context 才能相互独立的隔离运行。 另外，我们可以为一个 context 设置预定义的全局属性，这个属性可以是 C++ 写的对象或方法，这样在 js 环境中，就能够调用 C++ 对象了，相当于扩充了 js 的能力。 比如，Node.js 中的 process 对象，就是一个预定义到 context 的对象，所以在 Node.js 中可以直接使用。同样的，浏览器中的 window document 等全局对象，也是预定义到 context 上的。 参考链接Getting started with embedding V8: https://v8.dev/docs/embed#advanced-guide","categories":[{"name":"Javascript Engine V8","slug":"Javascript-Engine-V8","permalink":"http://maslow.github.io/categories/Javascript-Engine-V8/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://maslow.github.io/tags/Node-js/"},{"name":"javascript","slug":"javascript","permalink":"http://maslow.github.io/tags/javascript/"},{"name":"V8","slug":"V8","permalink":"http://maslow.github.io/tags/V8/"},{"name":"C/C++","slug":"C-C","permalink":"http://maslow.github.io/tags/C-C/"}]},{"title":"Javascript Engine V8 Embedding - 编译","slug":"v8/compile-v8","date":"2018-03-25T15:47:14.000Z","updated":"2018-11-27T02:47:20.705Z","comments":true,"path":"2018/03/25/v8/compile-v8/","link":"","permalink":"http://maslow.github.io/2018/03/25/v8/compile-v8/","excerpt":"直接 git pull V8 的代码是不行的，需要使用 Google 提供的 depot_tools 工具包来获对代码并配置。 需要翻墙，下载和编译的耗时都很长，分别视你的网络情况和机器配置而定。 为了屏蔽掉不同系统的差异，直接使用 Docker 容器环境来编译。","text":"直接 git pull V8 的代码是不行的，需要使用 Google 提供的 depot_tools 工具包来获对代码并配置。 需要翻墙，下载和编译的耗时都很长，分别视你的网络情况和机器配置而定。 为了屏蔽掉不同系统的差异，直接使用 Docker 容器环境来编译。 编译1234567891011121314151617181920212223242526272829docker run -it ubuntu bash # 安装必要的工具apt updateapt install -y git curl python xz-utils lbzip2 lsb-release lsb-core sudo vim# 安装 Google 开发工具包# see more: https://v8.dev/docs/source-code#using-gitcd /root &amp;&amp; git clone https://chromium.googlesource.com/chromium/tools/depot_tools.gitexport PATH=$PATH:/root/depot_toolsgclient# 下载 v8 代码fetch v8cd v8git checkout refs/tags/7.1.11 -b sample -t# 同步依赖gclient sync# 创建一个构建配置tools/dev/v8gen.py x64.release.sample# 开始构建 v8 静态库# 构建耗时较长，视你的机器配置而定ninja -C out.gn/x64.release.sample v8_monolith 使用静态库等上面 v8 编译完成后，就可以使用编译好的静态库了，我们编译一下 v8 提供的 hello-world 示例： 1234567# 编译g++ -I. -Iinclude samples/hello-world.cc -o hello_world -lv8_monolith -Lout.gn/x64.release.sample/obj/ -pthread -std=c++0x # icu 数据文件，运行时需要cp out.gn/x64.release.sample/icudtl.dat ../hello_world 参考链接https://v8.dev/docs/embed https://v8.dev/docs/source-code#using-git","categories":[{"name":"Javascript Engine V8","slug":"Javascript-Engine-V8","permalink":"http://maslow.github.io/categories/Javascript-Engine-V8/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://maslow.github.io/tags/Node-js/"},{"name":"javascript","slug":"javascript","permalink":"http://maslow.github.io/tags/javascript/"},{"name":"V8","slug":"V8","permalink":"http://maslow.github.io/tags/V8/"},{"name":"C/C++","slug":"C-C","permalink":"http://maslow.github.io/tags/C-C/"}]}]}