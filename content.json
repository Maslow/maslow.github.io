{"meta":{"title":"老根's Blog","subtitle":"Stay hungry, Stay foolish","description":null,"author":"Maslow","url":"http://maslow.github.io"},"pages":[{"title":"","date":"2018-11-03T16:58:01.395Z","updated":"2018-11-03T16:58:01.395Z","comments":false,"path":"categories/index.html","permalink":"http://maslow.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-03T16:57:58.708Z","updated":"2018-11-03T16:57:58.708Z","comments":false,"path":"tags/index.html","permalink":"http://maslow.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-03T19:53:56.612Z","updated":"2018-11-03T19:53:56.611Z","comments":true,"path":"downloads/code/app.js","permalink":"http://maslow.github.io/downloads/code/app.js","excerpt":"","text":"const fs = require('fs')"}],"posts":[{"title":"Node.js 源码分析 - 原生模块的注册","slug":"nodejs/nodejs-src/register-builtin-modules","date":"2018-11-28T13:04:49.000Z","updated":"2018-12-02T15:05:40.104Z","comments":true,"path":"nodejs/nodejs-src/register-builtin-modules/","link":"","permalink":"http://maslow.github.io/nodejs/nodejs-src/register-builtin-modules/","excerpt":"上一篇提到 RegisterBuiltinModules() 注册了原生 C++ 模块没有详细展开，这里就从这个函数展开。","text":"上一篇提到 RegisterBuiltinModules() 注册了原生 C++ 模块没有详细展开，这里就从这个函数展开。 将 RegisterBuiltinModules() 层层展开12345678/* src/node.cc:3066 */// Call built-in modules' _register_&lt;module name&gt; function to// do module registration explicitly.void RegisterBuiltinModules() &#123;#define V(modname) _register_##modname(); NODE_BUILTIN_MODULES(V)#undef V&#125; 首先定义了一个宏 V 为 _register_##modname()，可以看出 V 展开后是一个函数调用类似这样： _register_xx()； 随后，RegisterBuiltinModules() 实际是宏 NODE_BUILTIN_MODULES(V) 来实现的，我们看看它的定义：1234/* src/node_internals.h:147 */#define NODE_BUILTIN_MODULES(V) \\ NODE_BUILTIN_STANDARD_MODULES(V)// ... 进一步查看 NODE_BUILTIN_STANDARD_MODULES(V) 的定义：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* src/node_internals.h:106 */// A list of built-in modules. In order to do module registration// in node::Init(), need to add built-in modules in the following list.// Then in node::RegisterBuiltinModules(), it calls modules' registration// function. This helps the built-in modules are loaded properly when// node is built as static library. No need to depend on the// __attribute__((constructor)) like mechanism in GCC.#define NODE_BUILTIN_STANDARD_MODULES(V) \\ V(async_wrap) \\ V(buffer) \\ V(cares_wrap) \\ V(config) \\ V(contextify) \\ V(domain) \\ V(fs) \\ V(fs_event_wrap) \\ V(heap_utils) \\ V(http2) \\ V(http_parser) \\ V(inspector) \\ V(js_stream) \\ V(messaging) \\ V(module_wrap) \\ V(options) \\ V(os) \\ V(performance) \\ V(pipe_wrap) \\ V(process_wrap) \\ V(serdes) \\ V(signal_wrap) \\ V(spawn_sync) \\ V(stream_pipe) \\ V(stream_wrap) \\ V(string_decoder) \\ V(symbols) \\ V(tcp_wrap) \\ V(timer_wrap) \\ V(trace_events) \\ V(tty_wrap) \\ V(types) \\ V(udp_wrap) \\ V(url) \\ V(util) \\ V(uv) \\ V(v8) \\ V(worker) \\ V(zlib) 这个宏定义中多次调用宏 V，还记得这个宏吗，在上面定义的：#define V(modname) _register_##modname();，那我们把它展开后就是：1234567891011121314151617181920212223242526272829303132333435363738394041/* src/node_internals.h:106 */#define NODE_BUILTIN_STANDARD_MODULES(V) \\ _register_async_wrap(); _register_buffer(); _register_cares_wrap(); _register_config(); _register_contextify(); _register_domain(); _register_fs(); _register_fs_event_wrap(); _register_heap_utils(); _register_http2(); _register_http_parser(); _register_inspector(); _register_js_stream(); _register_messaging(); _register_module_wrap(); _register_options(); _register_os(); _register_performance(); _register_pipe_wrap(); _register_process_wrap(); _register_serdes(); _register_signal_wrap(); _register_spawn_sync(); _register_stream_pipe(); _register_stream_wrap(); _register_string_decoder(); _register_symbols(); _register_tcp_wrap(); _register_timer_wrap(); _register_trace_events(); _register_tty_wrap(); _register_types(); _register_udp_wrap(); _register_url(); _register_util(); _register_uv(); _register_v8(); _register_worker(); _register_zlib(); 最终，RegisterBuiltinModules() 展开后大概是这样的： 1234567void RegisterBuiltinModules() &#123; _register_async_wrap(); _register_buffer(); // ... _register_os(); // ...&#125; 经过层层的宏展开，我们看到 RegisterBuiltinModules() 的原貌，就是调用了一些全局注册函数，这样就能理解了。 接下来，我们打算看看这些注册函数是在哪里定义的。 我刚开始全局搜索了整个代码目录，也没找到这些函数中的任何一个，看来又是通过宏定义的。 我打算挑一个原生模块的源码，来看看里面有没有上面注册函数的定义，我挑了模块名为 os 的模块，它的源码位于 src/node_os.cc： 查看一个原生模块的源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* src/node_os.cc */namespace node &#123;namespace os &#123;// ...static void GetHostname(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetOSType(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetOSRelease(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetCPUInfo(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetFreeMemory(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetTotalMemory(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetUptime(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetLoadAvg(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetInterfaceAddresses(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetHomeDirectory(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetUserInfo(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void SetPriority(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetPriority(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;// 这个初始化函数是每个原生模块都会定义的，它的参数也是一致的void Initialize(Local&lt;Object&gt; target, Local&lt;Value&gt; unused, Local&lt;Context&gt; context) &#123; Environment* env = Environment::GetCurrent(context); env-&gt;SetMethod(target, \"getHostname\", GetHostname); env-&gt;SetMethod(target, \"getLoadAvg\", GetLoadAvg); env-&gt;SetMethod(target, \"getUptime\", GetUptime); env-&gt;SetMethod(target, \"getTotalMem\", GetTotalMemory); env-&gt;SetMethod(target, \"getFreeMem\", GetFreeMemory); env-&gt;SetMethod(target, \"getCPUs\", GetCPUInfo); env-&gt;SetMethod(target, \"getOSType\", GetOSType); env-&gt;SetMethod(target, \"getOSRelease\", GetOSRelease); env-&gt;SetMethod(target, \"getInterfaceAddresses\", GetInterfaceAddresses); env-&gt;SetMethod(target, \"getHomeDirectory\", GetHomeDirectory); env-&gt;SetMethod(target, \"getUserInfo\", GetUserInfo); env-&gt;SetMethod(target, \"setPriority\", SetPriority); env-&gt;SetMethod(target, \"getPriority\", GetPriority); target-&gt;Set(FIXED_ONE_BYTE_STRING(env-&gt;isolate(), \"isBigEndian\"), Boolean::New(env-&gt;isolate(), IsBigEndian()));&#125;&#125; // namespace os&#125; // namespace nodeNODE_BUILTIN_MODULE_CONTEXT_AWARE(os, node::os::Initialize) 这个 os 模块先是定义了一些函数，代码的最后是一个宏，这个宏把模块名 os 和 Initialize 函数做为其参数，我们找到它的定义如下：123/* src/node_internals.h:169 */#define NODE_BUILTIN_MODULE_CONTEXT_AWARE(modname, regfunc) \\ NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, nullptr, NM_F_BUILTIN) 又是一个宏定义，继续跟下去：12345678910111213141516/* src/node_internals.h:152*/#define NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags) \\ static node::node_module _module = &#123; \\ NODE_MODULE_VERSION, \\ flags, \\ nullptr, \\ __FILE__, \\ nullptr, \\ (node::addon_context_register_func) (regfunc), \\ NODE_STRINGIFY(modname), \\ priv, \\ nullptr \\ &#125;; \\ void _register_ ## modname() &#123; \\ node_module_register(&amp;_module); \\ &#125; 这个宏的定义里好像看到了我们要找的代码，我们在这里就可以把 NODE_BUILTIN_MODULE_CONTEXT_AWARE(os, node::os::Initialize) 完全展开了：12345678910111213141516// 创建一个 node_module 对象 _modulestatic node::node_module _module = &#123; NODE_MODULE_VERSION, NM_F_BUILTIN, nullptr, __FILE__, nullptr, (node::addon_context_register_func) (node::os::Initialize), NODE_STRINGIFY(os), nullptr, nullptr &#125;; // 定义我们要找的 _register_os() 函数void _register_os() &#123; node_module_register(&amp;_module); &#125; 到此，我们就明白了 RegisterBuiltinModules() 函数中调用的 _register_os() 是在哪里定义的了，随后查看了所有原生模块的代码，最后一行都是相同的作法声明相应的 _register_xx()。 其中 node::node_module 类型就代表一个模块的信息。 所谓注册 os 模块实际是调用了 node_module_register(node_module *) 函数完成的，我们继续来看看 node_module_register() 函数和 node::node_module： 模块注册实现12345678910111213/* src/node.h:518*/struct node_module &#123; int nm_version; unsigned int nm_flags; void* nm_dso_handle; const char* nm_filename; // 上例中 Initialize 函数被赋到 nm_register_func 里 node::addon_register_func nm_register_func; node::addon_context_register_func nm_context_register_func; const char* nm_modname; // 模块的名字 void* nm_priv; struct node_module* nm_link; &#125;; 12345678910111213141516171819202122/* src/node.cc:1094 */extern \"C\" void node_module_register(void* m) &#123; struct node_module* mp = reinterpret_cast&lt;struct node_module*&gt;(m); if (mp-&gt;nm_flags &amp; NM_F_BUILTIN) &#123; // 链表操作 mp-&gt;nm_link = modlist_builtin; modlist_builtin = mp; &#125; else if (mp-&gt;nm_flags &amp; NM_F_INTERNAL) &#123; // 链表操作 mp-&gt;nm_link = modlist_internal; modlist_internal = mp; &#125; else if (!node_is_initialized) &#123; // \"Linked\" modules are included as part of the node project. // Like builtins they are registered *before* node::Init runs. mp-&gt;nm_flags = NM_F_LINKED; mp-&gt;nm_link = modlist_linked; modlist_linked = mp; &#125; else &#123; uv_key_set(&amp;thread_local_modpending, mp); &#125;&#125; 到这里就清晰了， 所谓原生模块的注册，实际上就是将一个类型为 node::node_module 的模块对象，添加到不同类别的全局链表中。 上述代码中用3个全局链表：modlist_builtin modlist_internal modlist_linked 分别保存不同类型的模块，本文我们说的是 BUILTIN 类型的，也就是第一个。","categories":[{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"http://maslow.github.io/categories/Node-js-源码分析/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://maslow.github.io/tags/Node-js/"},{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"http://maslow.github.io/tags/Node-js-源码分析/"},{"name":"源码分析","slug":"源码分析","permalink":"http://maslow.github.io/tags/源码分析/"}]},{"title":"Node.js 源码分析 - 从 main 函数开始","slug":"nodejs/nodejs-src/the-main","date":"2018-11-27T13:30:15.000Z","updated":"2018-11-27T18:35:30.192Z","comments":true,"path":"nodejs/nodejs-src/the-main/","link":"","permalink":"http://maslow.github.io/nodejs/nodejs-src/the-main/","excerpt":"小目标 知道程序大概执行逻辑，关键点执行的顺序 我们平时在命令敲下 node app.js 后，发生了什么。 具体点，知道 node.js 原生(C++)模块什么时候加载的，在哪加载的;知道我们的 js 代码是在哪个环节被加载执行的；知道进程的主循环（事件循环）什么时候启动的； 有了这个小目标的基础，在接下来的文章中，我们再进一步的探索 node.js 原生模块的注册是怎么实现的，怎么获取 &amp; 初始化的，怎么曝露给 js 环境调用的；再细说 node.js 的模块机制，我们通常的 app.js 怎么被执行的；","text":"小目标 知道程序大概执行逻辑，关键点执行的顺序 我们平时在命令敲下 node app.js 后，发生了什么。 具体点，知道 node.js 原生(C++)模块什么时候加载的，在哪加载的;知道我们的 js 代码是在哪个环节被加载执行的；知道进程的主循环（事件循环）什么时候启动的； 有了这个小目标的基础，在接下来的文章中，我们再进一步的探索 node.js 原生模块的注册是怎么实现的，怎么获取 &amp; 初始化的，怎么曝露给 js 环境调用的；再细说 node.js 的模块机制，我们通常的 app.js 怎么被执行的； 贴代码说明限于篇幅，本文只先把大体执行流程捋出来，后面再开文一块块的捋。 原代码太长，先把不影响我们分析的无关代码去掉，贴上来有关整体执行逻辑的代码，代码中的 // ... 注释意思是这个地方有被省略的代码。 每段代码第一行的注释都会指出源文件位置，一些代码讲解会在代码段中的注释中进行； 本文不再介绍 V8 和 Libuv 的知识，会开专门的分类写 V8 和 Libuv，参考 Node.js 源码分析 - 前言 开捋：从 main 函数到进程主循环main 函数12345/* src/node_main.cc:93 */int main(int argc, char* argv[]) &#123; // ... return node::Start(argc, argv);&#125; main函数 在 src/node_main.cc 这个文件中，这个文件主要就是存放 main函数。 很简单，只是调用了 node::Start()，这个函数在 src/node.cc 这个文件中，接下来的核心代码都在这个文件中。 初始化 V8 引擎123456789101112131415161718192021222324/* src/node.cc:3011 */int Start(int argc, char** argv) &#123; // ... std::vector&lt;std::string&gt; args(argv, argv + argc); std::vector&lt;std::string&gt; exec_args; // This needs to run *before* V8::Initialize(). Init(&amp;args, &amp;exec_args); // ... v8_platform.Initialize(per_process_opts-&gt;v8_thread_pool_size); V8::Initialize(); // ... const int exit_code = Start(uv_default_loop(), args, exec_args); v8_platform.StopTracingAgent(); v8_initialized = false; V8::Dispose(); v8_platform.Dispose(); return exit_code;&#125; 在这段代码，首先进行 V8 的初始化，然后调用了另外一个 Start(uv_loop_t*, ...)函数，最后释放资源，进程结束； 其中值得注意的一点，在初始化 V8 之前，调用了一个 Init() 函数，这个函数主要完成了 Node.js 原生(C++)模块的注册，就是 fs http等模块的 C++ 实现模块。 1234567/* src/node.cc:2559 */void Init(std::vector&lt;std::string&gt;* argv, std::vector&lt;std::string&gt;* exec_argv) &#123; // ... // Register built-in modules RegisterBuiltinModules(); // ...&#125; Init() 中调用了 RegisterBuiltinModules()，它注册了所有 Node.js 原生模块，关于原生模块的注册，本文不再继续跟进去，下一篇会单独展开这一块，这里先知道这个流程。 记住这个 RegisterBuiltinModules()，下一篇文章就从这里开始展开。 创建 Isolate 实例12345678910111213141516171819202122/* src/node.cc:2964 */inline int Start(uv_loop_t* event_loop, const std::vector&lt;std::string&gt;&amp; args, const std::vector&lt;std::string&gt;&amp; exec_args) &#123; std::unique_ptr&lt;ArrayBufferAllocator, decltype(&amp;FreeArrayBufferAllocator)&gt; allocator(CreateArrayBufferAllocator(), &amp;FreeArrayBufferAllocator); // 创建 Isolate 实例 Isolate* const isolate = NewIsolate(allocator.get()); // ... int exit_code; &#123; Locker locker(isolate); Isolate::Scope isolate_scope(isolate); HandleScope handle_scope(isolate); // ... exit_code = Start(isolate, isolate_data.get(), args, exec_args); &#125; // ... isolate-&gt;Dispose(); return exit_code;&#125; 这个 Start() 倒也没做什么，主要工作是创建了 Isolate 实例，然后调用了另外一个 Start(Isolate*...)。 进程主循环1234567891011121314151617181920212223242526272829303132333435363738394041/* src/node.cc:2868 */inline int Start(Isolate* isolate, IsolateData* isolate_data, const std::vector&lt;std::string&gt;&amp; args, const std::vector&lt;std::string&gt;&amp; exec_args) &#123; HandleScope handle_scope(isolate); // 创建 V8 Context 对象 Local&lt;Context&gt; context = NewContext(isolate); Context::Scope context_scope(context); // 创建 Environment 对象，这个是 Node.js 的类 Environment env(isolate_data, context, v8_platform.GetTracingAgentWriter()); // 这里面主要完成 libuv 的初始化，以及创建 process 对象 // 就是 Node.js 中那个全局的 process 对象，这里不细展开 env.Start(args, exec_args, v8_is_profiling); &#123; // ... // LoadEnvironment 是本文重要的关键点 LoadEnvironment(&amp;env); env.async_hooks()-&gt;pop_async_id(1); &#125; // 下面就是进程的主循环 &#123; // ... bool more; // ... do &#123; uv_run(env.event_loop(), UV_RUN_DEFAULT); // ... more = uv_loop_alive(env.event_loop()); if (more) continue; // ... &#125; while (more == true); &#125; // ... return exit_code;&#125; 这段代码创建并使用了 js 执行需要的 context，然后创建了 Environment 对象； 这个 Environment 对象是 Node.js 源码中重要的一个对象，它是一个全局单例，定义和存储了一些重要的全局对象和函数，比如刚开始创建的 Isolate 对象、刚刚创建的 Context 对象等，注意它不是 V8 的，是 Node.js 定义的，对它的使用贯穿整个 Node.js 执行的生命周期。 再下面是进程的主循环，uv_run() 启动了 Libuv 的事件循环， 它也是 Node.js 进程的主循环，Libuv 会单独写文介绍。 最后说一下，中间的 LoadEnvironment() 调用，它是在程序进入主循环之前最关键的一环； LoadEnvironment() 完成了一些 js 文件的加载和执行，其中就包括加载执行通常编写的 app.js。 主循环之前1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* src/node.cc:2115 */void LoadEnvironment(Environment* env) &#123; HandleScope handle_scope(env-&gt;isolate()); // ... // The bootstrapper scripts are lib/internal/bootstrap/loaders.js and // lib/internal/bootstrap/node.js, each included as a static C string // defined in node_javascript.h, generated in node_javascript.cc by // node_js2c. // 加载两个重要的 js 文件：internal/bootstrap/loaders.js // 和 internal/bootstrap/node.js Local&lt;String&gt; loaders_name = FIXED_ONE_BYTE_STRING(env-&gt;isolate(), \"internal/bootstrap/loaders.js\"); MaybeLocal&lt;Function&gt; loaders_bootstrapper = GetBootstrapper(env, LoadersBootstrapperSource(env), loaders_name); Local&lt;String&gt; node_name = FIXED_ONE_BYTE_STRING(env-&gt;isolate(), \"internal/bootstrap/node.js\"); MaybeLocal&lt;Function&gt; node_bootstrapper = GetBootstrapper(env, NodeBootstrapperSource(env), node_name); // ... // Add a reference to the global object Local&lt;Object&gt; global = env-&gt;context()-&gt;Global(); env-&gt;SetMethod(env-&gt;process_object(), \"_rawDebug\", RawDebug); // Expose the global object as a property on itself // (Allows you to set stuff on `global` from anywhere in JavaScript.) global-&gt;Set(FIXED_ONE_BYTE_STRING(env-&gt;isolate(), \"global\"), global); // 准备 binding 函数，下面调用 js 会作为参数传给 js 环境 // Create binding loaders Local&lt;Function&gt; get_binding_fn = env-&gt;NewFunctionTemplate(GetBinding)-&gt;GetFunction(env-&gt;context()) .ToLocalChecked(); Local&lt;Function&gt; get_linked_binding_fn = env-&gt;NewFunctionTemplate(GetLinkedBinding)-&gt;GetFunction(env-&gt;context()) .ToLocalChecked(); Local&lt;Function&gt; get_internal_binding_fn = env-&gt;NewFunctionTemplate(GetInternalBinding)-&gt;GetFunction(env-&gt;context()) .ToLocalChecked(); // 准备执行 internal/bootstrap/loaders.js 文件的参数 Local&lt;Value&gt; loaders_bootstrapper_args[] = &#123; env-&gt;process_object(), get_binding_fn, get_linked_binding_fn, get_internal_binding_fn, Boolean::New(env-&gt;isolate(), env-&gt;options()-&gt;debug_options-&gt;break_node_first_line) &#125;; // 执行 internal/bootstrap/loaders.js // Bootstrap internal loaders // 这个对象是用来接收执行结果的，记住是 bootstrapped_loaders，下面会用到 Local&lt;Value&gt; bootstrapped_loaders; if (!ExecuteBootstrapper(env, loaders_bootstrapper.ToLocalChecked(), arraysize(loaders_bootstrapper_args), loaders_bootstrapper_args, &amp;bootstrapped_loaders)) &#123; return; &#125; // 准备执行 internal/bootstrap/node.js 的参数 // Bootstrap Node.js Local&lt;Object&gt; bootstrapper = Object::New(env-&gt;isolate()); SetupBootstrapObject(env, bootstrapper); Local&lt;Value&gt; bootstrapped_node; Local&lt;Value&gt; node_bootstrapper_args[] = &#123; env-&gt;process_object(), bootstrapper, // 注意，这里是上面执行 loaders.js 返回的结果对象， // 作为执行参数传给 internal/bootstrap/node.js bootstrapped_loaders &#125;; // 执行 internal/bootstrap/node.js if (!ExecuteBootstrapper(env, node_bootstrapper.ToLocalChecked(), arraysize(node_bootstrapper_args), node_bootstrapper_args, &amp;bootstrapped_node)) &#123; return; &#125;&#125; LoadEnvironment() 首先加载了两个 js 文件，这两个 js 文件的位置分别在：lib/internal/bootstrap/loaders.js 和 lib/internal/bootstrap/node.js。 我们 Node.js 开发者写的 app.js 其实就是在这两个 js 文件中加载并执行的，这块是最重要的逻辑之一，内容也很多，后面的文章会详细展开。 LoadEnvironment() 接下来创建了三个 binding 函数： get_binding_fn get_linked_binding_fn get_internal_binding_fn 这3个 binding 函数是用来获取和加载 Node.js 原生模块的，会传入到 js 执行环境中，也就是你在 js 代码中是可以调用的，比如 process.binding(&#39;fs&#39;)，在我们用 C++ 开发 Node.js 扩展模块的时候，也会用到，以后会详细展开。 LoadEnvironment() 接下来要执行 lib/internal/bootstrap/loaders.js，在这个 js 文件中主要定义了内部(internal)模块加载器(loaders)。 lib/internal/bootstrap/loaders.js 定义的模块加载器(loaders) 接下来做为执行参数，传入了 lib/internal/bootstrap/node.js，在 lib/internal/bootstrap/node.js 中会使用这些 loaders 来加载 internal 模块。 lib/internal/bootstrap/node.js 做了很多工作，这里只需要知道，它最终加载并执行了我们 Node.js 程序员编写的 app.js 就可以了。 到此为止，我们就知道了在命令行敲下 node app.js 大概发生了哪些事！ 小结这只是个大概逻辑，可以配合 Node.js 源码，再花时间捋一捋，光靠贴的这点代码，可能还是会迷糊的。 接下来的文章，就是对这个执行逻辑中的关键点分别展开。 作者水平有限，写的也仓促，有误之处还请指出。","categories":[{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"http://maslow.github.io/categories/Node-js-源码分析/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://maslow.github.io/tags/Node-js/"},{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"http://maslow.github.io/tags/Node-js-源码分析/"},{"name":"源码分析","slug":"源码分析","permalink":"http://maslow.github.io/tags/源码分析/"}]},{"title":"Node.js 源码分析 - 前言","slug":"nodejs/nodejs-src/index","date":"2018-11-24T14:30:15.000Z","updated":"2018-12-02T15:07:12.020Z","comments":true,"path":"nodejs/nodejs-src/index/","link":"","permalink":"http://maslow.github.io/nodejs/nodejs-src/index/","excerpt":"这两年先后两次读过 Node.js 源码，但是每次都懒于记录，过几个月就忘记了，这次把疏理过程记录下来，免得以后再费时间从头看。虽然是为了备忘，我会尽量以读者的角度去写，希望能给想了解 Node.js 源码的朋友节省一些时间。 适合谁- 你需要熟悉 C/C++ - 你需要熟悉 Node.js，理解异步编程及原理","text":"这两年先后两次读过 Node.js 源码，但是每次都懒于记录，过几个月就忘记了，这次把疏理过程记录下来，免得以后再费时间从头看。虽然是为了备忘，我会尽量以读者的角度去写，希望能给想了解 Node.js 源码的朋友节省一些时间。 适合谁- 你需要熟悉 C/C++ - 你需要熟悉 Node.js，理解异步编程及原理 分析方式根据执行流程，直接从 main 函数开始走， 然后再单独分析具体模块。 疏理执行逻辑是这次分析的重点。 代码我使用的版本是 node.js 仓库里 v10.x 分支。123git clone git@github.com:nodejs/node.git cd nodegit checkout v10.x 目录V8 Embedding: Javascript Engine V8 Embedding - 编译 Javascript Engine V8 Embedding - Hello World 讲解 Node.js 源码分析: 从 main 函数开始 原生模块的注册 持续更新中 相关资料 Libuv 官网 User Guide 很友好：http://docs.libuv.org/en/v1.x/guide.html Node.js 源码：https://github.com/nodejs/node Node.js 源码构建：https://github.com/nodejs/node/blob/master/BUILDING. V8 构建：https://v8.dev/docs/build V8 Embedding: https://v8.dev/docs/embed","categories":[{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"http://maslow.github.io/categories/Node-js-源码分析/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://maslow.github.io/tags/Node-js/"},{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"http://maslow.github.io/tags/Node-js-源码分析/"},{"name":"源码分析","slug":"源码分析","permalink":"http://maslow.github.io/tags/源码分析/"}]},{"title":"动手写一个简单的 Promise.js","slug":"javascript/diy-simple-promise-js","date":"2018-11-23T18:07:14.000Z","updated":"2018-11-23T19:00:16.701Z","comments":true,"path":"javascript/diy-simple-promise-js/","link":"","permalink":"http://maslow.github.io/javascript/diy-simple-promise-js/","excerpt":"初学 Node.js 的朋友总会耗一番周折去理解 Promise，这里给出一个最简单的 Promise 实现，以帮助对 Promise 还有疑惑的同学彻底理解其实现原理。","text":"初学 Node.js 的朋友总会耗一番周折去理解 Promise，这里给出一个最简单的 Promise 实现，以帮助对 Promise 还有疑惑的同学彻底理解其实现原理。 这个代码应该是三年前我刚接触 Node.js 的时候写的了，当时也是 Google 不少关于 Promise 的文章，现在已经不记得相关链接了。 这个并不是完整的 Promise 逻辑，旨在理解 Promise 的实现原理，由于过了太久，我就直接贴出来代码不做解释说明了。如果先前有用过 Promise 的话，应该还是较容易理解的； 若是初接触，这个逻辑还是有点绕，先去其它地方了解 Promse 的用法，再多花点时间去理一理这段代码，是值得的。 12345678910111213141516171819202122232425262728293031323334353637383940// Promisefunction Promise(fn) &#123; var self = this self.state = 'PENDING' self.onFulfilled = null self.onRejected = null self.then = function (onResolved, onRejected) &#123; var that = this; return new Promise(function (resolve, reject) &#123; that.onFulfilled = function (val) &#123; var ret = onResolved ? onResolved(val) : val; if (ret &amp;&amp; ret.then) &#123; ret.then(function (val) &#123; resolve(val) &#125;) &#125; else &#123; resolve(ret); &#125; &#125;; that.onRejected = function (val) &#123; var ret = onRejected ? onRejected(val) : val; reject(ret); &#125;; &#125;); &#125; fn &amp;&amp; fn(function (result) &#123; if (self.state === 'PENDING') &#123; self.state = 'FULFILLED'; setTimeout(function()&#123; self.onFulfilled &amp;&amp; self.onFulfilled(result); &#125;,0) &#125; &#125;, function (reason) &#123; if (self.state === 'PENDING') &#123; self.state = 'REJECTED'; self.onRejected &amp;&amp; self.onRejected(reason); &#125; &#125;);&#125; 使用示例：12345678910111213function sleep(t) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function () &#123; console.log(t) resolve(t) &#125;, t) &#125;)&#125;sleep(1000) .then(data =&gt; sleep(data + 1)) .then(data =&gt; sleep(data + 1)) .then(data =&gt; sleep(data + 1))","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://maslow.github.io/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://maslow.github.io/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"http://maslow.github.io/tags/promise/"}]},{"title":"GitLab CI 示例：构建 & 测试 Node.js 应用","slug":"gitlab-ci/example-node-js","date":"2018-11-23T16:18:13.000Z","updated":"2018-11-23T19:11:53.509Z","comments":true,"path":"gitlab-ci/example-node-js/","link":"","permalink":"http://maslow.github.io/gitlab-ci/example-node-js/","excerpt":"通过解释说明一个简单的 Node.js 应用的 Pipeline 示例来介绍 GitLab CI 的工作方式和使用。 其中会重点介绍 GitLab CI 的执行过程，Stage Job 等基础概念，以及缓存策略。","text":"通过解释说明一个简单的 Node.js 应用的 Pipeline 示例来介绍 GitLab CI 的工作方式和使用。 其中会重点介绍 GitLab CI 的执行过程，Stage Job 等基础概念，以及缓存策略。 示例定义下面是一个简单的 Node.js 应用的 pipeline 定义：123456789101112131415161718192021# .gitlab-ci.ymlstages: - build - testcache: paths: - node_modules/build_job: image: node:10 stage: build script: - npm version - npm installtest_job: image: node:10 stage: test script: - npm run test 解释说明逐一介绍一下这几个字段： stages123stages: - build - test stage 定义了 pipeline 的执行步骤，也就是说 stages 是有序执行的。每个 stages 可包括多个 Job，Job 才是 CI Runner 要执行的任务。 上面的 pipeline 包括 build 和 test 两个步骤，先执行完所有 build 阶段的 Job，才会执行 test 阶段的 Job。 如果 build 阶段的 Job 执行失败了，则整个 pipeline 失败并中断执行，不会继续执行 test stage 了。 下面就来介绍什么是 Job. build_job123456build_job: image: node:10 stage: build script: - npm version - npm install build_job 是 Job 的名称，可以自由定义； stage 字段指定该 Job 属于 build 阶段的； script 就是自定义的构建脚本了，这里就是简单的 npm install； image 这个是指定 script 脚本的执行环境，它的值应该是一个 Docker 镜像。 Runner 开始执行这个 Job 时，首先会 pull 项目的最新代码，然后基于这个镜像启动一个容器并把代码挂载到容器里，最后在这个容器里面执行 script 定义的脚本。因为我们这里使用的是 node:10 作为作业的镜像，所以在 script 里才可以直接用 npm。 test_job12345test_job: image: node:10 stage: test script: - npm run test test_job 同样是一个 Job，它属于 test stage，在上面的 stages 定义中 test 是在 build 之后的，所以它会等所有 build 阶段的 Job 执行完之后才会被执行。 重点来了：每个 Job 是独立执行的，互相隔离的。 Runner 在执行 test_job 的时候，会重新 pull 应用的最新代码，然后启动一个新容器并挂载代码，再在里面执行 script 脚本。 这就会导致一个问题： 在 test_job 中我们并没有执行 npm install 就直接执行了 npm run test，理论上会是报错的！ 这就要介绍最后一个未介绍的字段 cache. cache123cache: paths: - node_modules/ cache 是 pipeline 中定义 Job 之间的缓存的； 我们这里定义的 cache 是全局的，即作用于所有 Job 的； paths 定义需要缓存的目录，若需要，你可以指定多个； 缓存的逻辑是这样的： - 执行 build_job 时会检查之前无有缓存 - 如果有缓存就下载到 `paths` 指定的缓存目录，无则忽略 - build_job 执行结束之前，会重新把缓存目录缓存起来 - test_job 执行之前，同样检查有无缓存，有则下载 所以，test_job 的 script 中没有执行 npm install 是因为我们将 node_modules 目录缓存了。 缓存是提高 Job 执行效率的策略，不仅仅是多个 Job 之间； 同一个 Job 在多次 pipeline 中也会共用缓存，意思是： - build_job 第一次运行时并没有缓存 - 下次 pipeline 执行时，npm install 就会基于缓存的 node_modules 更新，而不是全量下载了 总结通过这个示例，基本就了解 GitLab CI 的工作过程和定义方式了； 其中缓存策略是非常常用的，这里使用的是全局缓存，还可以指定某个 Job 特有有缓存策略。 想进一步了解缓存，请查看官方文档关于缓存的详细说明:https://docs.gitlab.com/ee/ci/yaml/README.html#cache 这个简单的示例，只是展示了 Node.js 应用的构建和测试，一个更完整的 CI 流程通常还会包括 部署(deploy)，接下来会继续通过示例讲解使用 GitLab CI 的更多使用。","categories":[{"name":"GitLab CI/CD","slug":"GitLab-CI-CD","permalink":"http://maslow.github.io/categories/GitLab-CI-CD/"},{"name":"GitLab CI Examples","slug":"GitLab-CI-CD/GitLab-CI-Examples","permalink":"http://maslow.github.io/categories/GitLab-CI-CD/GitLab-CI-Examples/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://maslow.github.io/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"http://maslow.github.io/tags/gitlab-ci/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://maslow.github.io/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","permalink":"http://maslow.github.io/tags/DevOps/"}]},{"title":"GitLab CI 基本介绍","slug":"gitlab-ci/index","date":"2018-11-08T16:03:53.000Z","updated":"2018-11-23T19:03:06.360Z","comments":true,"path":"gitlab-ci/index/","link":"","permalink":"http://maslow.github.io/gitlab-ci/index/","excerpt":"这篇基本介绍只介绍 GitLab CI，不会写具体的使用细节，旨在让新接触 GitLab CI 的同学先对它有个基本的认识，直接看官网文档可能需要多花点时间才能理清一些概念。 GitLab CI 的设计很灵活，有多种使用方案，我在接下来会针对最常用的几种情况写一系列包括实现细节步骤的文章。","text":"这篇基本介绍只介绍 GitLab CI，不会写具体的使用细节，旨在让新接触 GitLab CI 的同学先对它有个基本的认识，直接看官网文档可能需要多花点时间才能理清一些概念。 GitLab CI 的设计很灵活，有多种使用方案，我在接下来会针对最常用的几种情况写一系列包括实现细节步骤的文章。 前置需求当前有 3 台服务器 develop, staging, production 分别对应代码仓库上的三个分支：develop, staging, master。 要求 push 代码到仓库时会触发 CI 的执行： 1. build app 2. testing app 3. deploy to server 代码 push 到哪个分支，就把项目部署到相应的服务器上。 GitLab CI 的重要概念要理解 GitLab CI 的工作方式，必须要理解两个概念： - Pipeline - Runner 上面说的 CI 执行过程就是 pipeline，它定义了项目的构建、测试、部署等的执行过程。 我们需要在每个项目上定义一个 pipeline。 定义一个 pipeline 就是在项目代码根目录创建文件：.gitlab-ci.yml. 定义好 pipeline 后，GitLab CI 会读取并执行这个 pipeline，执行的程序叫做 Runner。 Runner 是负责执行 pipeline 的程序。 通常 Runner 需要我们自己安装并运行在自己的服务器上，当然也可以使用 gitlab.com 官方提供的免费的 Shared Runner 服务。 GitLab CI 的工作方式 Pipeline 的触发当开发者 Push 代码到某个分支时，如果我们定义了 Pipeline，也就是代码根目录中有 .gitlab-ci.yml 文件，GitLab 会自动触发 Pipeline 的执行。 Pipeline 的执行Pipeline 执行时，首先会 pull 下来被触发分支的代码，然后执行你在 pipline 中定义的 Job，Job 是你指定的一些 shell scripts，它就是你构建项目的逻辑。 小结简单介绍一下 GitLab CI 的几个重要概念，接下来会通过实例来详细讲解 GitLab CI 的使用。","categories":[{"name":"GitLab CI/CD","slug":"GitLab-CI-CD","permalink":"http://maslow.github.io/categories/GitLab-CI-CD/"},{"name":"GitLab CI 基本介绍","slug":"GitLab-CI-CD/GitLab-CI-基本介绍","permalink":"http://maslow.github.io/categories/GitLab-CI-CD/GitLab-CI-基本介绍/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://maslow.github.io/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"http://maslow.github.io/tags/gitlab-ci/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://maslow.github.io/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","permalink":"http://maslow.github.io/tags/DevOps/"}]},{"title":"Javascript Engine V8 Embedding - Hello World 讲解","slug":"v8/v8-embedding-hello-world","date":"2018-03-26T15:47:14.000Z","updated":"2018-11-27T04:26:03.018Z","comments":true,"path":"v8/v8-embedding-hello-world/","link":"","permalink":"http://maslow.github.io/v8/v8-embedding-hello-world/","excerpt":"通过一个 Hello World 示例来介绍 V8 的几个重要概念。 这个示例代码是基于 V8 (7.1) 的，要编译这个示例请查看 Javascript Engine V8 Embedding - 编译","text":"通过一个 Hello World 示例来介绍 V8 的几个重要概念。 这个示例代码是基于 V8 (7.1) 的，要编译这个示例请查看 Javascript Engine V8 Embedding - 编译 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include \"include/libplatform/libplatform.h\"#include \"include/v8.h\"int main(int argc, char* argv[]) &#123; // 初始化 V8 v8::V8::InitializeICUDefaultLocation(argv[0]); v8::V8::InitializeExternalStartupData(argv[0]); std::unique_ptr&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform(); v8::V8::InitializePlatform(platform.get()); v8::V8::Initialize(); // 创建一个 Isolate 实例, 它代表一个 JS VM 实例 v8::Isolate::CreateParams create_params; create_params.array_buffer_allocator = v8::ArrayBuffer::Allocator::NewDefaultAllocator(); v8::Isolate* isolate = v8::Isolate::New(create_params); &#123; // 使用 isolat\be v8::Isolate::Scope isolate_scope(isolate); // 创建一个 HandleScope，用于管理 Handle 的生命周期 v8::HandleScope handle_scope(isolate); // 创建 Context，它是 javascript 代码执行的环境上下文对象 v8::Local&lt;v8::Context&gt; context = v8::Context::New(isolate); // 进入 or 使用 context v8::Context::Scope context_scope(context); &#123; // 定义 JS 代码字符串 v8::Local&lt;v8::String&gt; source = v8::String::NewFromUtf8(isolate, \"'Hello' + ', World!'\", v8::NewStringType::kNormal).ToLocalChecked(); // 编译 JS 代码 v8::Local&lt;v8::Script&gt; script = v8::Script::Compile(context, source).ToLocalChecked(); // 运行 JS 代码，并获取结果 v8::Local&lt;v8::Value&gt; result = script-&gt;Run(context).ToLocalChecked(); // 将运行结果转换为 UTF8 字符串，并打印 v8::String::Utf8Value utf8(isolate, result); printf(\"%s\\n\", *utf8); &#125; &#125; // 释放 V8 相关资源 isolate-&gt;Dispose(); v8::V8::Dispose(); v8::V8::ShutdownPlatform(); delete create_params.array_buffer_allocator; return 0;&#125; V8 重要概念Isolate一个 Isolate 就是一个 VM 实例，它有自己独立的 Heap。 Handle一个 Handle 就是对一个 V8 object 的引用， V8 objects 都是分配在 Heap 中的，所有 V8 objects 都需要通过一个Handle 引用来访问，才能保证 V8 garbage collector 能工作。 Handle 又分 Local（局部） 和 Persistent（全局）两种。 Local Handle 的生命周期 使用 HandleScope 来管理，而 Persistent 是全局的 Handle， 需要通过 Persistent::New() 和 Persistent::Release() 来创建和释放。 Handle Scope一个 Handle Scope 可以理解为用来批量管理 Handle 的容器，这样我们就不用一个个的去释放 Handle，只要把它们的 Handle Scope 释放掉就可以了。 Handle Scope 相当于提供了 Handle Stack 机制来管理 Handles，当一个 Handle Scope 本身被释放的时候，会从 Handle Stack 上弹出所有基于它的 Local Handles。 注意：这个 Handle Stack 并不是 C++ 调用栈， Handle Scope 是在 C++ 调用栈 中的分配的，Handle Scope 必须创建在栈上，不能用 new 创建！ ContextContext 是 javascript 代码的执行环境； 想像一下，你有多个不相关的 js 代码要运行，这些代码运行的过程中可能会修改 V8 全局的一些状态，就需要给他们指定不同的 context 才能相互独立的隔离运行。 另外，我们可以为一个 context 设置预定义的全局属性，这个属性可以是 C++ 写的对象或方法，这样在 js 环境中，就能够调用 C++ 对象了，相当于扩充了 js 的能力。 比如，Node.js 中的 process 对象，就是一个预定义到 context 的对象，所以在 Node.js 中可以直接使用。同样的，浏览器中的 window document 等全局对象，也是预定义到 context 上的。 参考链接Getting started with embedding V8: https://v8.dev/docs/embed#advanced-guide","categories":[{"name":"Javascript Engine V8","slug":"Javascript-Engine-V8","permalink":"http://maslow.github.io/categories/Javascript-Engine-V8/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://maslow.github.io/tags/javascript/"},{"name":"V8","slug":"V8","permalink":"http://maslow.github.io/tags/V8/"},{"name":"Node.js","slug":"Node-js","permalink":"http://maslow.github.io/tags/Node-js/"},{"name":"C/C++","slug":"C-C","permalink":"http://maslow.github.io/tags/C-C/"}]},{"title":"Javascript Engine V8 Embedding - 编译","slug":"v8/compile-v8","date":"2018-03-25T15:47:14.000Z","updated":"2018-11-27T02:47:20.705Z","comments":true,"path":"v8/compile-v8/","link":"","permalink":"http://maslow.github.io/v8/compile-v8/","excerpt":"直接 git pull V8 的代码是不行的，需要使用 Google 提供的 depot_tools 工具包来获对代码并配置。 需要翻墙，下载和编译的耗时都很长，分别视你的网络情况和机器配置而定。 为了屏蔽掉不同系统的差异，直接使用 Docker 容器环境来编译。","text":"直接 git pull V8 的代码是不行的，需要使用 Google 提供的 depot_tools 工具包来获对代码并配置。 需要翻墙，下载和编译的耗时都很长，分别视你的网络情况和机器配置而定。 为了屏蔽掉不同系统的差异，直接使用 Docker 容器环境来编译。 编译1234567891011121314151617181920212223242526272829docker run -it ubuntu bash # 安装必要的工具apt updateapt install -y git curl python xz-utils lbzip2 lsb-release lsb-core sudo vim# 安装 Google 开发工具包# see more: https://v8.dev/docs/source-code#using-gitcd /root &amp;&amp; git clone https://chromium.googlesource.com/chromium/tools/depot_tools.gitexport PATH=$PATH:/root/depot_toolsgclient# 下载 v8 代码fetch v8cd v8git checkout refs/tags/7.1.11 -b sample -t# 同步依赖gclient sync# 创建一个构建配置tools/dev/v8gen.py x64.release.sample# 开始构建 v8 静态库# 构建耗时较长，视你的机器配置而定ninja -C out.gn/x64.release.sample v8_monolith 使用静态库等上面 v8 编译完成后，就可以使用编译好的静态库了，我们编译一下 v8 提供的 hello-world 示例： 1234567# 编译g++ -I. -Iinclude samples/hello-world.cc -o hello_world -lv8_monolith -Lout.gn/x64.release.sample/obj/ -pthread -std=c++0x # icu 数据文件，运行时需要cp out.gn/x64.release.sample/icudtl.dat ../hello_world 参考链接https://v8.dev/docs/embed https://v8.dev/docs/source-code#using-git","categories":[{"name":"Javascript Engine V8","slug":"Javascript-Engine-V8","permalink":"http://maslow.github.io/categories/Javascript-Engine-V8/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://maslow.github.io/tags/javascript/"},{"name":"V8","slug":"V8","permalink":"http://maslow.github.io/tags/V8/"},{"name":"Node.js","slug":"Node-js","permalink":"http://maslow.github.io/tags/Node-js/"},{"name":"C/C++","slug":"C-C","permalink":"http://maslow.github.io/tags/C-C/"}]}]}