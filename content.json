{"meta":{"title":"老根's Blog","subtitle":"stay hungry, stay foolish","description":"Fullstack Developer","author":"Maslow","url":"https://laogen.site"},"pages":[{"title":"","date":"2018-11-03T16:58:01.395Z","updated":"2018-11-03T16:58:01.395Z","comments":false,"path":"categories/index.html","permalink":"https://laogen.site/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-03T16:57:58.708Z","updated":"2018-11-03T16:57:58.708Z","comments":false,"path":"tags/index.html","permalink":"https://laogen.site/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-03T19:53:56.612Z","updated":"2018-11-03T19:53:56.611Z","comments":true,"path":"downloads/code/app.js","permalink":"https://laogen.site/downloads/code/app.js","excerpt":"","text":"const fs = require('fs')"}],"posts":[{"title":"Javascript async/await 原理 & 实现","slug":"javascript/deep-into-async-await","date":"2019-02-28T13:30:14.000Z","updated":"2019-02-28T14:34:24.439Z","comments":true,"path":"javascript/deep-into-async-await/","link":"","permalink":"https://laogen.site/javascript/deep-into-async-await/","excerpt":"ES7 在语法层面上支持了 async/await 关键字，我们将在代码层面上模拟实现 async/await 来理解它的工作原理。 本文旨在说明其工作原理，你应该具备以下前置知识： 熟悉 Promise 的概念及使用 熟悉 async/await 的概念及使用 了解 Generator 的概念","text":"ES7 在语法层面上支持了 async/await 关键字，我们将在代码层面上模拟实现 async/await 来理解它的工作原理。 本文旨在说明其工作原理，你应该具备以下前置知识： 熟悉 Promise 的概念及使用 熟悉 async/await 的概念及使用 了解 Generator 的概念 Generator 基础复习首先复习一下 Js Generator 的基本用法： 1234567891011121314151617181920function * work() &#123; const r = yield 'hi' console.log(r) // 'ha' return&#125;const gen = work()console.log(gen) // Object [Generator] &#123;&#125;let result = gen.next()console.log(result) // &#123; value: 'hi', done: false &#125;result = gen.next('ha')console.log(result) // &#123; value: undefined', done: true &#125;// output summary:// Object [Generator] &#123;&#125;// &#123; value: 'hi', done: false &#125;// ha// &#123; value: undefined', done: true &#125; 我们调用 work() 这个函数时它返回的是一个 Generator 对象 gen；然后我们调用 gen.next() 返回值是 { value: &#39;hi&#39;, done: false }, 其中 value 字段就是 yield 关键字返回给我们的数据，done 字段表示该 Generator 函数当前并没有执行结束，并且暂停在了 yield 所在的这一行。 当我们第二次调用 gen.next(&#39;ha&#39;) 的时候，Generator 函数继续执行，并将我们传给 next() 函数的参数值 &#39;ha&#39; 返回并赋值给变量 r，然后继续运行并打印出 r，直到遇到 return 语句，函数返回 { value: undefined&#39;, done: true } 给我们。 其中 value 是返回值， done 表示 Generator 函数已执行结束并返回。 Generator 函数的一个特点是可以使用 yeild 关键字暂停当前函数的执行，并向调用者返回相应数据以及自己的运行状态（ 代码中的 done 字段）。另外一个特点是，调用者通过 next() 函数恢复 Generator 执行时可以通过参数传数据给 Generator 作为 yield 的返回值 （赋给代码中的变量 r)。 run()有了前面关于 Generator 知识的复习，我们实现本文的核心函数；它接收一个 Generator 函数 fn 作为参数，它的功能就是模拟 async/await 机制运行该 fn 函数。 1234567891011121314function run(fn) &#123; const gen = fn() function _next(data)&#123; const &#123; value, done &#125; = gen.next(data) if(done) return value if(value.then)&#123; value.then(data =&gt; _next(data)) &#125;else&#123; _next(value) &#125; &#125; _next()&#125; 在解释我们这个 run() 函数之前，先看一下它的用法示例: 12345678910111213141516171819function sleep(duration) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout( () =&gt; resolve(`slept $&#123;duration&#125;ms`), duration) &#125;)&#125;function * work () &#123; // 假设 request.get() 返回 Promise，这里就不去实现了 const ret = yield sleep(1000) console.log(ret) const ret2 = yield sleep(2000) console.log(ret2)&#125;run(work)// output// slept 1000ms// slept 2000ms 看了这个示例代码，应该就能明白 run() 的作用了，实际上通过这个函数，我们已经模拟实现了 async/await 机制； 我们做个不严谨的类比来说明： function * work() { } 中间的 * 号就相当于 async 关键字的作用； yield 关键字就相当于 await 关键字； 总结实际上 async/await 关键字也可以认为是 ES7 的语法糖，我们已经通过 run() 函数来模拟了其工作原理，至于 Js 引擎具体怎么实现的，未来我们写 分析 v8 引擎实现相关文章的时候再细究。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://laogen.site/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laogen.site/tags/javascript/"},{"name":"async/await","slug":"async-await","permalink":"https://laogen.site/tags/async-await/"},{"name":"async/await 原理","slug":"async-await-原理","permalink":"https://laogen.site/tags/async-await-原理/"}]},{"title":"Javascript 构造函数、new、bind()、call() 原理理解","slug":"javascript/constructor-bind-call-apply","date":"2019-02-28T06:11:14.000Z","updated":"2019-02-28T14:33:49.949Z","comments":true,"path":"javascript/constructor-bind-call-apply/","link":"","permalink":"https://laogen.site/javascript/constructor-bind-call-apply/","excerpt":"其它语言开发者初接触 Js 时，会对构造函数、new 关键字有些迷糊，因为这两个概念在其它 OO 语言中是很基本的概念，但在 Js 中用起来和在以前熟悉的语言中有些不一样，引起一些困惑。","text":"其它语言开发者初接触 Js 时，会对构造函数、new 关键字有些迷糊，因为这两个概念在其它 OO 语言中是很基本的概念，但在 Js 中用起来和在以前熟悉的语言中有些不一样，引起一些困惑。 问题在 C++/Java/PHP 中都有 class 的概念，class 有构造函数以及通过 new 实例化对象看起来都很理所当然，没什么可疑惑的。 为什么会对 Js 中的 new 构造函数就会产生一些疑惑呢，因为我们对这两个概念先入为主了。 我们先抛开一般 OO 语言中的 class 等这些语法、概念，从更 “原始” 的角度去理解这两个概念及其作用，理解起来就变得非常简单。 构造函数构造函数 在 C++/java/PHP 中构造函数在形式上比较特殊，它们需要定义在一个 class 中，并且往往还有固定的函数名等。 抛开这些说，构造函数 首先是一个函数，这个函数基本作用是用来初始化一个实例对象。 在 Js 中，构造函数就是一个普通函数，它的定义也和普通的函数一样: 123function Person(name)&#123; this.name = name&#125; 那么我们要怎么用这个函数 Person 来初始化一个对象呢？这就要提到 执行环境 这个概念了，也就是 Person 函数中的 this 关键字，它就代表当前函数执行时的 执行环境，在这里也就是我们要初始化的那个对象。 123let obj = &#123;&#125;Person.call(obj, 'laogen')console.log(obj) // &#123;name: 'laogen'&#125; 这段代码就实现了——调用 Person 这个函数初始化了 obj 这个对象。也就是说，我们通过 call 调用函数，第一个参数就是该函数的 执行环境，也就是 Person 中的 this。 但上面这段实例化对象的代码 “不好看”，不像在 Java/C++ 中直接使用 new 来的简洁，我们用以下代码来模拟实现一个类似 Java/C++ 的实例化语法： 指定一个构造函数及其参数 返回一个实例化的对象 12345678function New(constructor, ...args)&#123; let obj = &#123;&#125; constructor.call(obj, ...args) return obj&#125;// 用法如下let obj3 = New(Person, 'laogen3')console.log(obj3) // &#123; name: 'laogen3' &#125; 这个用法看起来就很 “像” Java/C++/PHP 中实例化一个对象的用法了。 当然，在 Js 中有同样简洁的方式创建和初始化一个实例： 12let obj2 = new Person('laogen2')console.log(obj2) // &#123; name: 'laogen2' &#125; 到这里，你肯定就明白 new 一个构造函数到底是怎么回事了。你可以把 new 理解为一个语法糖，其实际工作就是我们上面模拟的 New 函数所做的。 也就是说 new 关键字首先创建了一个对象，然后调用 Person 函数初始化这个对象。 另外一个问题，我们直接调用构造函数 Person() 而不用 new 来调用会是什么样呢？ Person() 里面的 this 到底指向什么对象呢？ 12345function Person(name)&#123; this.name = name&#125;Person('laogen4')console(name) // \"laogen4\" 我们直接调用 Person() 而不通过 new 调用，结果就是在当前执行环境中创建并初始化了 name 属性，所以直接打印 name 输出了 &quot;laogen4&quot;。 也就是说，如果我们直接调用 Person()，那么它的 this 就指向这个函数调用所在的执行环境，如果是在全局环境中调用的，那么这个执行环境： 在 Node.js 中就是 global 对象；在浏览器中通常是 window 对象。 this &amp; call()我们上面是通过调用 call 函数来完成的，那这个 call 又是怎么实现的呢？ 这个 call 函数当然是 Js 本身就支持的，我们通过下面代码模拟实现它，以便更好的理解其原理，因为 this 是 Js 关键字，不可用做标识符，我们用 that 来模拟代替 this: 123456789101112function Person(name)&#123; // 在这里约定最后一个参数是 `that` let that = arguments[arguments.length - 1] that.name = name&#125;Person.call = function(that, ...args) &#123; Person(...args, that)&#125;let obj3 = &#123;&#125;Person.call(obj3, 'laogen3')console.log(obj3) // &#123; name: 'laogen3' &#125; 通过这段代码可以看出， call() 把它的第一个参数以某种方式传给了被调用的函数 Person()，并作用 Person() 函数的 this （也就是代码中的 that)。 这段代码只是模拟过程，实际上 this 对象并不是通过被调用函数的最后一个传数来传递的，这个是 Js 编译器层面去实现的，这里不细究。 bind()123456789101112function Person(name)&#123; this.name = name&#125;Person.bind(target, ...args)&#123; return () =&gt; Person.call(target, ...args)&#125;let obj4 = &#123;&#125;let func = Person.bind(obj4, 'laogen4')func()console.log(obj4) // &#123; name: 'laogen4' &#125; 这段代码模拟实现了 bind() 函数的逻辑，bind() 与 call() 的区别在于： bind() 并不调用 Person() 函数，它只是返回一个新函数，在这个新函数里调用了 call()。 总结这篇文主要说明了 Js 构造函数只是普通的函数，和其它 OO 语言不同的是，它并没有很特别的地方，构造函数的主要作用就是初始化实例对象； 通过模拟代码解释了 new 关键字的内部逻辑，以更好的理解构造函数的工作原理； 通过模拟 this 更进一步的理解 执行环境 的概念； 通过模拟 call() 和 bind() 方法，更直观深入的理解两者的逻辑和使用；","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://laogen.site/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laogen.site/tags/javascript/"},{"name":"constructor","slug":"constructor","permalink":"https://laogen.site/tags/constructor/"},{"name":"new","slug":"new","permalink":"https://laogen.site/tags/new/"},{"name":"call()","slug":"call","permalink":"https://laogen.site/tags/call/"},{"name":"bind()","slug":"bind","permalink":"https://laogen.site/tags/bind/"}]},{"title":"Js Engine V8 Embedding - 回调函数","slug":"v8/expose-cpp-func-callback","date":"2019-01-13T13:07:07.000Z","updated":"2019-01-20T07:13:19.457Z","comments":true,"path":"v8/expose-cpp-func-callback/","link":"","permalink":"https://laogen.site/v8/expose-cpp-func-callback/","excerpt":"目标上一篇写处理函数参数，漏掉了 callback 函数做为参数的情况，这里给个简单的示例。 用 C++ 写一个简单 RunFunc() v8 函数传给 js 环境，使以下代码可运行： 123456// app.jsfunction fn (msg) &#123; console.log(msg)&#125;RunFunc(fn)","text":"目标上一篇写处理函数参数，漏掉了 callback 函数做为参数的情况，这里给个简单的示例。 用 C++ 写一个简单 RunFunc() v8 函数传给 js 环境，使以下代码可运行： 123456// app.jsfunction fn (msg) &#123; console.log(msg)&#125;RunFunc(fn) 代码 &amp; 说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// callback.cc// callback.cc#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include \"include/libplatform/libplatform.h\"#include \"include/v8.h\"using namespace v8;using std::cout;using std::endl;using std::ifstream;using std::strcpy;using std::string;using std::stringstream;// run js callbackvoid RunCallback(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); // 调用回调函数需要 context 对象 Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext(); Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[0]); // 准备回调函数的参数 const unsigned argc = 1; Local&lt;Value&gt; argv[argc] = &#123;String::NewFromUtf8(isolate, \"hello world\")&#125;; // 调用 cb-&gt;Call(context, Null(isolate), argc, argv).ToLocalChecked();&#125;// 读取 js 代码char* ReadSourceCodeFile(const char* path) &#123; ifstream f(path); stringstream buffer; buffer &lt;&lt; f.rdbuf(); const string str = buffer.str(); char* cstr = new char[str.length() + 1]; strcpy(cstr, str.c_str()); return cstr;&#125;void ConsoleLog(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); Local&lt;String&gt; str = Local&lt;String&gt;::Cast(args[0]); String::Utf8Value utf8(isolate, str); cout &lt;&lt; *utf8 &lt;&lt; endl; args.GetReturnValue().SetUndefined();&#125;int main(int argc, char* argv[]) &#123; // 初始化 V8 V8::InitializeICUDefaultLocation(argv[0]); V8::InitializeExternalStartupData(argv[0]); std::unique_ptr&lt;Platform&gt; platform = platform::NewDefaultPlatform(); V8::InitializePlatform(platform.get()); V8::Initialize(); // 创建 Isolate 实例 Isolate::CreateParams create_params; create_params.array_buffer_allocator = ArrayBuffer::Allocator::NewDefaultAllocator(); Isolate* isolate = Isolate::New(create_params); &#123; Isolate::Scope isolate_scope(isolate); // 创建一个 HandleScope，用于管理 Handle 的生命周期 HandleScope handle_scope(isolate); // 创建对象模板 `console_tpl` Local&lt;ObjectTemplate&gt; console_tpl = ObjectTemplate::New(isolate); console_tpl-&gt;Set(String::NewFromUtf8(isolate, \"log\"), FunctionTemplate::New(isolate, ConsoleLog)); Local&lt;FunctionTemplate&gt; cb_fn_tpl = FunctionTemplate::New(isolate, RunCallback); // 初始化 `global_template` Local&lt;ObjectTemplate&gt; global_template = ObjectTemplate::New(isolate); global_template-&gt;Set(String::NewFromUtf8(isolate, \"console\"), console_tpl); global_template-&gt;Set(String::NewFromUtf8(isolate, \"RunFunc\"), cb_fn_tpl); // 创建 Context，将 `global_template` 做为它的 global 对象模板 Local&lt;Context&gt; context = Context::New(isolate, NULL, global_template); Context::Scope context_scope(context); &#123; // 通过命令行第一个参数读取 js 文件代码 const char* js_code = ReadSourceCodeFile(argv[1]); Local&lt;String&gt; source = String::NewFromUtf8(isolate, js_code); // 编译 Local&lt;Script&gt; script = Script::Compile(context, source).ToLocalChecked(); // v8 异常捕获 TryCatch trycatch(isolate); MaybeLocal&lt;Value&gt; result = script-&gt;Run(context); // v8 异常处理 if (trycatch.HasCaught()) &#123; Local&lt;Value&gt; exception = trycatch.Exception(); String::Utf8Value exception_str(isolate, exception); cout &lt;&lt; *exception_str &lt;&lt; endl; &#125; delete js_code; &#125; &#125; isolate-&gt;Dispose(); V8::Dispose(); V8::ShutdownPlatform(); delete create_params.array_buffer_allocator; return 0;&#125; 编译v8 编译相关请查看 Javascript Engine V8 Embedding - 编译 1g++ -I. -Iinclude calback.cc -lv8_monolith -Lout.gn/x64.release.sample/obj/ -pthread -std=c++0x -o inode 执行1./inode app.js # output: `hello world` 说明代码已经比较清晰了，跟上一篇函数传参处理的内容是一致的，还配有简单的注释说明。 下篇，我们将探索如何封装 C++ 类，然后就可以无障碍的编写 Node.js C++ Addon 或 阅读 Node.js 源码了。 相关链接 Getting started with embedding V8: https://v8.dev/docs/embed#advanced-guide Node.js C++ Addons: https://nodejs.org/dist/latest-v10.x/docs/api/addons.html","categories":[{"name":"Javascript Engine V8","slug":"Javascript-Engine-V8","permalink":"https://laogen.site/categories/Javascript-Engine-V8/"},{"name":"V8 Embedding Basics","slug":"Javascript-Engine-V8/V8-Embedding-Basics","permalink":"https://laogen.site/categories/Javascript-Engine-V8/V8-Embedding-Basics/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laogen.site/tags/javascript/"},{"name":"V8","slug":"V8","permalink":"https://laogen.site/tags/V8/"},{"name":"Node.js","slug":"Node-js","permalink":"https://laogen.site/tags/Node-js/"},{"name":"C/C++","slug":"C-C","permalink":"https://laogen.site/tags/C-C/"}]},{"title":"Js Engine V8 Embedding -  V8 函数传参、返回、异常处理","slug":"v8/expose-cpp-func-params","date":"2019-01-03T13:07:07.000Z","updated":"2019-01-20T07:13:15.952Z","comments":true,"path":"v8/expose-cpp-func-params/","link":"","permalink":"https://laogen.site/v8/expose-cpp-func-params/","excerpt":"目标上一篇我们只是简单的把 C++ 环境中的函数暴露到 Javascript 环境中调用，这篇我们更进一步，学会操作函数参数、返回值以及 V8 异常处理。 写一个简单 Math.add() 函数传给 js 环境，使以下代码可运行： 12345// app.jsconst a = 1023const b = 1const sum = Math.add(a, b)console.log(sum)","text":"目标上一篇我们只是简单的把 C++ 环境中的函数暴露到 Javascript 环境中调用，这篇我们更进一步，学会操作函数参数、返回值以及 V8 异常处理。 写一个简单 Math.add() 函数传给 js 环境，使以下代码可运行： 12345// app.jsconst a = 1023const b = 1const sum = Math.add(a, b)console.log(sum) 然后我们修改一下这个 app.js，给 Math.add() 传入非法参数，学习处理 V8 异常： 12345// app.jsconst a = \"1023\"const b = 1const sum = Math.add(a, b)console.log(sum) 代码 &amp; 说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134// expose-func-params.cc#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include \"include/libplatform/libplatform.h\"#include \"include/v8.h\"using namespace v8;using std::cout;using std::endl;using std::ifstream;using std::strcpy;using std::string;using std::stringstream;// 两个实数相加void Add(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); // 参数检验 if (args.Length() &lt; 2) &#123; // 抛出可在 js 环境中捕获的异常 isolate-&gt;ThrowException(Exception::TypeError( String::NewFromUtf8(isolate, \"Wrong number of arguments\", NewStringType::kNormal) .ToLocalChecked())); return; &#125; // 检查参数类型 if (!args[0]-&gt;IsNumber() || !args[1]-&gt;IsNumber()) &#123; isolate-&gt;ThrowException(Exception::TypeError( String::NewFromUtf8(isolate, \"Wrong arguments\", NewStringType::kNormal) .ToLocalChecked())); return; &#125; // 执行加法操作 double value = args[0].As&lt;Number&gt;()-&gt;Value() + args[1].As&lt;Number&gt;()-&gt;Value(); Local&lt;Number&gt; num = Number::New(isolate, value); // 使用 `args` 来 return 计算结果 args.GetReturnValue().Set(num);&#125;// 读取 js 代码char* ReadSourceCodeFile(const char* path) &#123; ifstream f(path); stringstream buffer; buffer &lt;&lt; f.rdbuf(); const string str = buffer.str(); char* cstr = new char[str.length() + 1]; strcpy(cstr, str.c_str()); return cstr;&#125;void ConsoleLog(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); Local&lt;String&gt; str = Local&lt;String&gt;::Cast(args[0]); String::Utf8Value utf8(isolate, str); cout &lt;&lt; *utf8 &lt;&lt; endl; args.GetReturnValue().SetUndefined();&#125;int main(int argc, char* argv[]) &#123; // 初始化 V8 V8::InitializeICUDefaultLocation(argv[0]); V8::InitializeExternalStartupData(argv[0]); std::unique_ptr&lt;Platform&gt; platform = platform::NewDefaultPlatform(); V8::InitializePlatform(platform.get()); V8::Initialize(); // 创建 Isolate 实例 Isolate::CreateParams create_params; create_params.array_buffer_allocator = ArrayBuffer::Allocator::NewDefaultAllocator(); Isolate* isolate = Isolate::New(create_params); &#123; Isolate::Scope isolate_scope(isolate); // 创建一个 HandleScope，用于管理 Handle 的生命周期 HandleScope handle_scope(isolate); // 创建对象模板 `console_tpl` Local&lt;ObjectTemplate&gt; console_tpl = ObjectTemplate::New(isolate); console_tpl-&gt;Set(String::NewFromUtf8(isolate, \"log\"), FunctionTemplate::New(isolate, ConsoleLog)); // 创建对象模板 `math_tpl` Local&lt;ObjectTemplate&gt; math_tpl = ObjectTemplate::New(isolate); math_tpl-&gt;Set(String::NewFromUtf8(isolate, \"add\"), FunctionTemplate::New(isolate, Add)); // 初始化 `global_template` Local&lt;ObjectTemplate&gt; global_template = ObjectTemplate::New(isolate); global_template-&gt;Set(String::NewFromUtf8(isolate, \"console\"), console_tpl); global_template-&gt;Set(String::NewFromUtf8(isolate, \"Math\"), math_tpl); // 创建 Context，将 `global_template` 做为它的 global 对象模板 Local&lt;Context&gt; context = Context::New(isolate, NULL, global_template); Context::Scope context_scope(context); &#123; // 通过命令行第一个参数读取 js 文件代码 const char* js_code = ReadSourceCodeFile(argv[1]); Local&lt;String&gt; source = String::NewFromUtf8(isolate, js_code); // 编译 Local&lt;Script&gt; script = Script::Compile(context, source).ToLocalChecked(); // v8 异常捕获 TryCatch trycatch(isolate); MaybeLocal&lt;Value&gt; result = script-&gt;Run(context); // v8 异常处理 if (trycatch.HasCaught()) &#123; Local&lt;Value&gt; exception = trycatch.Exception(); String::Utf8Value exception_str(isolate, exception); cout&lt;&lt; *exception_str&lt;&lt; endl; &#125; delete js_code; &#125; &#125; isolate-&gt;Dispose(); V8::Dispose(); V8::ShutdownPlatform(); delete create_params.array_buffer_allocator; return 0;&#125; 编译v8 编译相关请查看 Javascript Engine V8 Embedding - 编译 1g++ -I. -Iinclude expose-func-params.cc -lv8_monolith -Lout.gn/x64.release.sample/obj/ -pthread -std=c++0x -o inode 执行1./inode app.js # output: `1024` 说明代码已经比较清晰了，还配有简单的注释说明。 这节主要是展示 V8 函数参数的处理，抛出 js 异常，在 C++ 中处理 V8 抛出的异常。 到这篇为止，我们已经可以很自由的扩展 js 的能力了, 可以用 V8 做出很 cool 的东西了。 相关链接 Getting started with embedding V8: https://v8.dev/docs/embed#advanced-guide Node.js C++ Addons: https://nodejs.org/dist/latest-v10.x/docs/api/addons.html","categories":[{"name":"Javascript Engine V8","slug":"Javascript-Engine-V8","permalink":"https://laogen.site/categories/Javascript-Engine-V8/"},{"name":"V8 Embedding Basics","slug":"Javascript-Engine-V8/V8-Embedding-Basics","permalink":"https://laogen.site/categories/Javascript-Engine-V8/V8-Embedding-Basics/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laogen.site/tags/javascript/"},{"name":"V8","slug":"V8","permalink":"https://laogen.site/tags/V8/"},{"name":"Node.js","slug":"Node-js","permalink":"https://laogen.site/tags/Node-js/"},{"name":"C/C++","slug":"C-C","permalink":"https://laogen.site/tags/C-C/"}]},{"title":"Js Engine V8 Embedding - C++ 函数暴露给 Javascript 环境","slug":"v8/expose-cpp-function","date":"2018-12-13T13:07:07.000Z","updated":"2019-01-20T07:13:12.699Z","comments":true,"path":"v8/expose-cpp-function/","link":"","permalink":"https://laogen.site/v8/expose-cpp-function/","excerpt":"目标上一篇我们把 C++ 环境中的对象暴露到 Javascript 环境中，这篇我们要将 C++ 环境中的 函数 暴露到 Javascript 环境中，写一个简单 console.log 函数传给 js 环境，使以下代码可运行： 12// app.jsconsole.log('Hi, 老根!')","text":"目标上一篇我们把 C++ 环境中的对象暴露到 Javascript 环境中，这篇我们要将 C++ 环境中的 函数 暴露到 Javascript 环境中，写一个简单 console.log 函数传给 js 环境，使以下代码可运行： 12// app.jsconsole.log('Hi, 老根!') 代码 &amp; 说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// expose-func.cc#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include \"include/libplatform/libplatform.h\"#include \"include/v8.h\"using namespace v8;using std::cout;using std::endl;using std::ifstream;using std::string;using std::stringstream;using std::strcpy;// 定义一个函数，用来读取 js 代码char* ReadSourceCodeFile(const char* path) &#123; ifstream f(path); stringstream buffer; buffer &lt;&lt; f.rdbuf(); const string str = buffer.str(); char* cstr = new char[str.length() + 1]; strcpy(cstr, str.c_str()); return cstr;&#125;// 这个函数会被暴露给 js 执行环境void ConsoleLog(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); Local&lt;String&gt; str = Local&lt;String&gt;::Cast(args[0]); String::Utf8Value utf8(isolate, str); cout &lt;&lt; *utf8 &lt;&lt; endl; args.GetReturnValue().SetUndefined();&#125;int main(int argc, char* argv[]) &#123; // 初始化 V8 V8::InitializeICUDefaultLocation(argv[0]); V8::InitializeExternalStartupData(argv[0]); std::unique_ptr&lt;Platform&gt; platform = platform::NewDefaultPlatform(); V8::InitializePlatform(platform.get()); V8::Initialize(); // 创建 Isolate 实例 Isolate::CreateParams create_params; create_params.array_buffer_allocator = ArrayBuffer::Allocator::NewDefaultAllocator(); Isolate* isolate = Isolate::New(create_params); &#123; Isolate::Scope isolate_scope(isolate); // 创建一个 HandleScope，用于管理 Handle 的生命周期 HandleScope handle_scope(isolate); // 创建一个 v8 对象模板 `console_tpl` Local&lt;ObjectTemplate&gt; console_tpl = ObjectTemplate::New(isolate); // 将 `ConsoleLog` 函数设置为 `console_tpl` 的 `log` 方法 console_tpl-&gt;Set(String::NewFromUtf8(isolate, \"log\"), FunctionTemplate::New(isolate, ConsoleLog)); // 创建 v8 对象模板 `global_template` // 将上面的 `console_tpl` 设为其 `console` 属性 Local&lt;ObjectTemplate&gt; global_template = ObjectTemplate::New(isolate); global_template-&gt;Set(String::NewFromUtf8(isolate, \"console\"), console_tpl); // 创建 v8 Context，将 `global_template` 做为它的 global 对象模板 Local&lt;Context&gt; context = Context::New(isolate, NULL, global_template); // 进入 or 使用 context Context::Scope context_scope(context); &#123; // js 文件通过命令行第一个参数传递进来，读取 js 文件代码 const char* js_code = ReadSourceCodeFile(argv[1]); Local&lt;String&gt; source = String::NewFromUtf8(isolate, js_code); // 编译 Local&lt;Script&gt; script = Script::Compile(context, source).ToLocalChecked(); // 执行 Local&lt;Value&gt; result = script-&gt;Run(context).ToLocalChecked(); delete js_code; &#125; &#125; // 释放 V8 相关资源 isolate-&gt;Dispose(); V8::Dispose(); V8::ShutdownPlatform(); delete create_params.array_buffer_allocator; return 0;&#125; 编译v8 编译相关请查看 Javascript Engine V8 Embedding - 编译 1g++ -I. -Iinclude expose-func.cc -lv8_monolith -Lout.gn/x64.release.sample/obj/ -pthread -std=c++0x -o inode 执行1./inode app.js # output: `Hi, 老根!` 说明和上一篇同理，将函数暴露给 js 和 将变量暴露给 js 是类似的。都是将 C++ 对象绑定到 Context Global 对象上，通过这种方式，我们就可以扩展 js 的能力了。 相关链接 Getting started with embedding V8: https://v8.dev/docs/embed#advanced-guide Node.js C++ Addons: https://nodejs.org/dist/latest-v10.x/docs/api/addons.html","categories":[{"name":"Javascript Engine V8","slug":"Javascript-Engine-V8","permalink":"https://laogen.site/categories/Javascript-Engine-V8/"},{"name":"V8 Embedding Basics","slug":"Javascript-Engine-V8/V8-Embedding-Basics","permalink":"https://laogen.site/categories/Javascript-Engine-V8/V8-Embedding-Basics/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laogen.site/tags/javascript/"},{"name":"V8","slug":"V8","permalink":"https://laogen.site/tags/V8/"},{"name":"Node.js","slug":"Node-js","permalink":"https://laogen.site/tags/Node-js/"},{"name":"C/C++","slug":"C-C","permalink":"https://laogen.site/tags/C-C/"}]},{"title":"Js Engine V8 Embedding - C++ 变量暴露给 Javascript 环境","slug":"v8/expose-cpp-var","date":"2018-12-12T00:14:42.000Z","updated":"2019-01-20T07:13:06.525Z","comments":true,"path":"v8/expose-cpp-var/","link":"","permalink":"https://laogen.site/v8/expose-cpp-var/","excerpt":"目标上一篇通过 Hello World 示例了解了 v8 的核心概念和基本使用方式，这篇中我们要将 C++ 环境中的对象暴露到 Javascript 环境中，即在 Javascript 代码中可以使用在 C++ 环境中的数据。","text":"目标上一篇通过 Hello World 示例了解了 v8 的核心概念和基本使用方式，这篇中我们要将 C++ 环境中的对象暴露到 Javascript 环境中，即在 Javascript 代码中可以使用在 C++ 环境中的数据。 代码 &amp; 说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// expose-var.cpp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include \"include/libplatform/libplatform.h\"#include \"include/v8.h\"using namespace v8;int main(int argc, char* argv[]) &#123; // 初始化 V8 V8::InitializeICUDefaultLocation(argv[0]); V8::InitializeExternalStartupData(argv[0]); std::unique_ptr&lt;Platform&gt; platform = platform::NewDefaultPlatform(); V8::InitializePlatform(platform.get()); V8::Initialize(); // 创建 Isolate 实例 Isolate::CreateParams create_params; create_params.array_buffer_allocator = ArrayBuffer::Allocator::NewDefaultAllocator(); Isolate* isolate = Isolate::New(create_params); &#123; // 使 `isolate` 成为当前 Isolate Isolate::Scope isolate_scope(isolate); // 创建一个 HandleScope，用于管理 Handle 的生命周期 HandleScope handle_scope(isolate); // 定义三个 v8 变量 Local&lt;String&gt; myname = String::NewFromUtf8(isolate, \"Maslow\"); Local&lt;String&gt; myblog = String::NewFromUtf8(isolate, \"https://laogen.site\"); Local&lt;Number&gt; myage = Number::New(isolate, 25); // 创建一个 v8 对象模板 `author`，将上面的三个变量设为 `author` 的属性 Local&lt;ObjectTemplate&gt; author = ObjectTemplate::New(isolate); author-&gt;Set(String::NewFromUtf8(isolate, \"name\"), myname); author-&gt;Set(String::NewFromUtf8(isolate, \"age\"), myage); author-&gt;Set(String::NewFromUtf8(isolate, \"blog\"), myblog); // 创建一个 v8 对象模板 `global_template`，将上面的 `author` 设为其属性 Local&lt;ObjectTemplate&gt; global_template = ObjectTemplate::New(isolate); global_template-&gt;Set(String::NewFromUtf8(isolate, \"author\"), author); // 创建 v8 Context，将 `global_template` 做为它的 global 对象模板 Local&lt;Context&gt; context = Context::New(isolate, NULL, global_template); // 进入 or 使用 context Context::Scope context_scope(context); &#123; // 在 js 代码中就可以直接访问 global 中的对象了 const char* js_code = \"`My Info: $&#123;author.name&#125;, $&#123;author.age&#125; years old, visit $&#123;author.blog&#125;`\"; Local&lt;String&gt; source = String::NewFromUtf8(isolate, js_code); // 编译 JS 代码 Local&lt;Script&gt; script = Script::Compile(context, source).ToLocalChecked(); // 运行 JS 代码，并获取结果 Local&lt;Value&gt; result = script-&gt;Run(context).ToLocalChecked(); // 将运行结果转换为 UTF8 字符串，并打印 String::Utf8Value utf8(isolate, result); printf(\"%s\\n\", *utf8); &#125; &#125; // 释放 V8 相关资源 isolate-&gt;Dispose(); V8::Dispose(); V8::ShutdownPlatform(); delete create_params.array_buffer_allocator; return 0;&#125; 在我们创建一个 Context 对象时，可以指定一个 ObjectTemplate 做为它的全局对象模板（ Global ObjectTemplate )，我们只需要将 C++ 的变量挂（设置）到 Global ObjectTemplate 上，在 js 环境中就可以全局访问它们。 比如，浏览器中的 window document 等对象就是以这种方式提供给 js 执行环境的。 ObjectTemplate 与 Object 的区别在 v8 中，一个 Object 对象代表一个 js 对象；而 ObjectTemplate 对象，官方文档说它是 Object 对象的 “Blueprint”，简单的说，ObjectTemplate 是 Object 对象的 “定义”，可以用它来生成相应的 Object。 Gobal ObjectTemplate1Local&lt;ObjectTemplate&gt; global_template = ObjectTemplate::New(isolate); 这个 global_template 就是一个 ObjectTemplate，context 根据这它来生成 Global 对象，而 Global 对象里面的属性，我们在 js 环境中是可以全局访问的。 相关链接 Getting started with embedding V8: https://v8.dev/docs/embed#advanced-guide Node.js C++ Addons: https://nodejs.org/dist/latest-v10.x/docs/api/addons.html","categories":[{"name":"Javascript Engine V8","slug":"Javascript-Engine-V8","permalink":"https://laogen.site/categories/Javascript-Engine-V8/"},{"name":"V8 Embedding Basics","slug":"Javascript-Engine-V8/V8-Embedding-Basics","permalink":"https://laogen.site/categories/Javascript-Engine-V8/V8-Embedding-Basics/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laogen.site/tags/javascript/"},{"name":"V8","slug":"V8","permalink":"https://laogen.site/tags/V8/"},{"name":"Node.js","slug":"Node-js","permalink":"https://laogen.site/tags/Node-js/"},{"name":"C/C++","slug":"C-C","permalink":"https://laogen.site/tags/C-C/"}]},{"title":"Javascript Engine V8 Embedding - Hello World 讲解","slug":"v8/v8-embedding-hello-world","date":"2018-12-11T15:47:14.000Z","updated":"2019-01-20T07:12:37.136Z","comments":true,"path":"v8/v8-embedding-hello-world/","link":"","permalink":"https://laogen.site/v8/v8-embedding-hello-world/","excerpt":"通过一个 Hello World 示例来介绍 V8 的几个重要概念。 这个示例代码是基于 V8 (7.1) 的，要编译这个示例请查看 Javascript Engine V8 Embedding - 编译","text":"通过一个 Hello World 示例来介绍 V8 的几个重要概念。 这个示例代码是基于 V8 (7.1) 的，要编译这个示例请查看 Javascript Engine V8 Embedding - 编译 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include \"include/libplatform/libplatform.h\"#include \"include/v8.h\"int main(int argc, char* argv[]) &#123; // 初始化 V8 v8::V8::InitializeICUDefaultLocation(argv[0]); v8::V8::InitializeExternalStartupData(argv[0]); std::unique_ptr&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform(); v8::V8::InitializePlatform(platform.get()); v8::V8::Initialize(); // 创建一个 Isolate 实例, 它代表一个 JS VM 实例 v8::Isolate::CreateParams create_params; create_params.array_buffer_allocator = v8::ArrayBuffer::Allocator::NewDefaultAllocator(); v8::Isolate* isolate = v8::Isolate::New(create_params); &#123; // 使用 isolat\be v8::Isolate::Scope isolate_scope(isolate); // 创建一个 HandleScope，用于管理 Handle 的生命周期 v8::HandleScope handle_scope(isolate); // 创建 Context，它是 javascript 代码执行的环境上下文对象 v8::Local&lt;v8::Context&gt; context = v8::Context::New(isolate); // 进入 or 使用 context v8::Context::Scope context_scope(context); &#123; // 定义 JS 代码字符串 v8::Local&lt;v8::String&gt; source = v8::String::NewFromUtf8(isolate, \"'Hello' + ', World!'\", v8::NewStringType::kNormal).ToLocalChecked(); // 编译 JS 代码 v8::Local&lt;v8::Script&gt; script = v8::Script::Compile(context, source).ToLocalChecked(); // 运行 JS 代码，并获取结果 v8::Local&lt;v8::Value&gt; result = script-&gt;Run(context).ToLocalChecked(); // 将运行结果转换为 UTF8 字符串，并打印 v8::String::Utf8Value utf8(isolate, result); printf(\"%s\\n\", *utf8); &#125; &#125; // 释放 V8 相关资源 isolate-&gt;Dispose(); v8::V8::Dispose(); v8::V8::ShutdownPlatform(); delete create_params.array_buffer_allocator; return 0;&#125; V8 重要概念Isolate一个 Isolate 就是一个 VM 实例，它有自己独立的 Heap。 Handle一个 Handle 就是对一个 V8 object 的引用， V8 objects 都是分配在 Heap 中的，所有 V8 objects 都需要通过一个Handle 引用来访问，才能保证 V8 garbage collector 能工作。 Handle 又分 Local（局部） 和 Persistent（全局）两种。 Local Handle 的生命周期 使用 HandleScope 来管理，而 Persistent 是全局的 Handle， 需要通过 Persistent::New() 和 Persistent::Release() 来创建和释放。 Handle Scope一个 Handle Scope 可以理解为用来批量管理 Handle 的容器，这样我们就不用一个个的去释放 Handle，只要把它们的 Handle Scope 释放掉就可以了。 Handle Scope 相当于提供了 Handle Stack 机制来管理 Handles，当一个 Handle Scope 本身被释放的时候，会从 Handle Stack 上弹出所有基于它的 Local Handles。 注意：这个 Handle Stack 并不是 C++ 调用栈， Handle Scope 是在 C++ 调用栈 中的分配的，Handle Scope 必须创建在栈上，不能用 new 创建！ ContextContext 是 javascript 代码的执行环境； 想像一下，你有多个不相关的 js 代码要运行，这些代码运行的过程中可能会修改 V8 全局的一些状态，就需要给他们指定不同的 context 才能相互独立的隔离运行。 另外，我们可以为一个 context 设置预定义的全局属性，这个属性可以是 C++ 写的对象或方法，这样在 js 环境中，就能够调用 C++ 对象了，相当于扩充了 js 的能力。 比如，Node.js 中的 process 对象，就是一个预定义到 context 的对象，所以在 Node.js 中可以直接使用。同样的，浏览器中的 window document 等全局对象，也是预定义到 context 上的。 参考链接Getting started with embedding V8: https://v8.dev/docs/embed#advanced-guide","categories":[{"name":"Javascript Engine V8","slug":"Javascript-Engine-V8","permalink":"https://laogen.site/categories/Javascript-Engine-V8/"},{"name":"V8 Embedding Basics","slug":"Javascript-Engine-V8/V8-Embedding-Basics","permalink":"https://laogen.site/categories/Javascript-Engine-V8/V8-Embedding-Basics/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laogen.site/tags/javascript/"},{"name":"V8","slug":"V8","permalink":"https://laogen.site/tags/V8/"},{"name":"Node.js","slug":"Node-js","permalink":"https://laogen.site/tags/Node-js/"},{"name":"C/C++","slug":"C-C","permalink":"https://laogen.site/tags/C-C/"}]},{"title":"Javascript Engine V8 Embedding - 编译","slug":"v8/compile-v8","date":"2018-12-10T15:47:14.000Z","updated":"2019-01-20T07:13:22.804Z","comments":true,"path":"v8/compile-v8/","link":"","permalink":"https://laogen.site/v8/compile-v8/","excerpt":"直接 git pull V8 的代码是不行的，需要使用 Google 提供的 depot_tools 工具包来获对代码并配置。 由于要从 Google 下载资源，需要科学上网，下载和编译的耗时都较长，分别视你的网络情况和机器配置而定。 为了屏蔽掉不同系统的差异，直接使用 Docker 容器环境来编译。","text":"直接 git pull V8 的代码是不行的，需要使用 Google 提供的 depot_tools 工具包来获对代码并配置。 由于要从 Google 下载资源，需要科学上网，下载和编译的耗时都较长，分别视你的网络情况和机器配置而定。 为了屏蔽掉不同系统的差异，直接使用 Docker 容器环境来编译。 编译1234567891011121314151617181920212223242526272829docker run -it ubuntu bash # 安装必要的工具apt updateapt install -y git curl python xz-utils lbzip2 lsb-release lsb-core sudo vim# 安装 Google 开发工具包# see more: https://v8.dev/docs/source-code#using-gitcd /root &amp;&amp; git clone https://chromium.googlesource.com/chromium/tools/depot_tools.gitexport PATH=$PATH:/root/depot_toolsgclient# 下载 v8 代码fetch v8cd v8git checkout refs/tags/7.1.11 -b sample -t# 同步依赖gclient sync# 创建一个构建配置tools/dev/v8gen.py x64.release.sample# 开始构建 v8 静态库# 构建耗时较长，视你的机器配置而定ninja -C out.gn/x64.release.sample v8_monolith 使用静态库等上面 v8 编译完成后，就可以使用编译好的静态库了，我们编译一下 v8 提供的 hello-world 示例： 1234567# 编译g++ -I. -Iinclude samples/hello-world.cc -o hello_world -lv8_monolith -Lout.gn/x64.release.sample/obj/ -pthread -std=c++0x# icu 数据文件，运行时需要cp out.gn/x64.release.sample/icudtl.dat ../hello_world 参考链接https://v8.dev/docs/embed https://v8.dev/docs/source-code#using-git","categories":[{"name":"Javascript Engine V8","slug":"Javascript-Engine-V8","permalink":"https://laogen.site/categories/Javascript-Engine-V8/"},{"name":"V8 Embedding Basics","slug":"Javascript-Engine-V8/V8-Embedding-Basics","permalink":"https://laogen.site/categories/Javascript-Engine-V8/V8-Embedding-Basics/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laogen.site/tags/javascript/"},{"name":"V8","slug":"V8","permalink":"https://laogen.site/tags/V8/"},{"name":"Node.js","slug":"Node-js","permalink":"https://laogen.site/tags/Node-js/"},{"name":"C/C++","slug":"C-C","permalink":"https://laogen.site/tags/C-C/"}]},{"title":"Node.js 源码分析 - 加载 app.js 之前","slug":"nodejs/nodejs-src/register-builtin-modules","date":"2018-11-28T13:04:49.000Z","updated":"2019-02-11T14:25:49.009Z","comments":true,"path":"nodejs/nodejs-src/register-builtin-modules/","link":"","permalink":"https://laogen.site/nodejs/nodejs-src/register-builtin-modules/","excerpt":"上一篇提到 RegisterBuiltinModules() 注册了原生 C++ 模块没有详细展开，这里就从这个函数展开。","text":"上一篇提到 RegisterBuiltinModules() 注册了原生 C++ 模块没有详细展开，这里就从这个函数展开。 将 RegisterBuiltinModules() 层层展开123456/* src/node.cc:3066 */void RegisterBuiltinModules() &#123;#define V(modname) _register_##modname(); NODE_BUILTIN_MODULES(V)#undef V&#125; 首先定义了一个宏 V 为 _register_##modname(), 可以看出 V 展开后是一个函数调用类似这样: _register_xx(); 随后，RegisterBuiltinModules() 实际是宏 NODE_BUILTIN_MODULES(V) 来实现的，我们看看它的定义： 1234/* src/node_internals.h:147 */#define NODE_BUILTIN_MODULES(V) \\ NODE_BUILTIN_STANDARD_MODULES(V)// ... 进一步查看 NODE_BUILTIN_STANDARD_MODULES(V) 的定义： 1234567891011121314151617181920212223242526272829303132333435363738394041/* src/node_internals.h:106 */#define NODE_BUILTIN_STANDARD_MODULES(V) \\ V(async_wrap) \\ V(buffer) \\ V(cares_wrap) \\ V(config) \\ V(contextify) \\ V(domain) \\ V(fs) \\ V(fs_event_wrap) \\ V(heap_utils) \\ V(http2) \\ V(http_parser) \\ V(inspector) \\ V(js_stream) \\ V(messaging) \\ V(module_wrap) \\ V(options) \\ V(os) \\ V(performance) \\ V(pipe_wrap) \\ V(process_wrap) \\ V(serdes) \\ V(signal_wrap) \\ V(spawn_sync) \\ V(stream_pipe) \\ V(stream_wrap) \\ V(string_decoder) \\ V(symbols) \\ V(tcp_wrap) \\ V(timer_wrap) \\ V(trace_events) \\ V(tty_wrap) \\ V(types) \\ V(udp_wrap) \\ V(url) \\ V(util) \\ V(uv) \\ V(v8) \\ V(worker) \\ V(zlib) 这个宏定义中多次调用宏 V，还记得这个宏吗，在上面定义的：#define V(modname) _register_##modname();，那我们把它展开后就是： 1234567891011121314151617181920212223242526272829303132333435363738394041/* src/node_internals.h:106 */#define NODE_BUILTIN_STANDARD_MODULES(V) \\ _register_async_wrap(); _register_buffer(); _register_cares_wrap(); _register_config(); _register_contextify(); _register_domain(); _register_fs(); _register_fs_event_wrap(); _register_heap_utils(); _register_http2(); _register_http_parser(); _register_inspector(); _register_js_stream(); _register_messaging(); _register_module_wrap(); _register_options(); _register_os(); _register_performance(); _register_pipe_wrap(); _register_process_wrap(); _register_serdes(); _register_signal_wrap(); _register_spawn_sync(); _register_stream_pipe(); _register_stream_wrap(); _register_string_decoder(); _register_symbols(); _register_tcp_wrap(); _register_timer_wrap(); _register_trace_events(); _register_tty_wrap(); _register_types(); _register_udp_wrap(); _register_url(); _register_util(); _register_uv(); _register_v8(); _register_worker(); _register_zlib(); 最终，RegisterBuiltinModules() 展开后大概是这样的： 1234567void RegisterBuiltinModules() &#123; _register_async_wrap(); _register_buffer(); // ... _register_os(); // ...&#125; 经过层层的宏展开，我们看到 RegisterBuiltinModules() 的原貌，就是调用了一些全局注册函数，这样就能理解了。 接下来，我们打算看看这些注册函数是在哪里定义的。 我全局搜索了整个代码目录，也没找到这些函数中的任何一个，看来又是通过宏定义的。 那我们就挑一个原生模块的源码，来看看里面有没有上面注册函数的定义，我挑了模块名为 os 的模块，它的源码位于 src/node_os.cc： 查看一个原生模块的源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* src/node_os.cc */namespace node &#123;namespace os &#123;// ...static void GetHostname(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetOSType(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetOSRelease(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetCPUInfo(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetFreeMemory(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetTotalMemory(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetUptime(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetLoadAvg(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetInterfaceAddresses(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetHomeDirectory(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetUserInfo(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void SetPriority(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;static void GetPriority(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; // ...&#125;// 这个初始化函数是每个原生模块都会定义的，它的参数也是一致的void Initialize(Local&lt;Object&gt; target, Local&lt;Value&gt; unused, Local&lt;Context&gt; context) &#123; Environment* env = Environment::GetCurrent(context); env-&gt;SetMethod(target, \"getHostname\", GetHostname); env-&gt;SetMethod(target, \"getLoadAvg\", GetLoadAvg); env-&gt;SetMethod(target, \"getUptime\", GetUptime); env-&gt;SetMethod(target, \"getTotalMem\", GetTotalMemory); env-&gt;SetMethod(target, \"getFreeMem\", GetFreeMemory); env-&gt;SetMethod(target, \"getCPUs\", GetCPUInfo); env-&gt;SetMethod(target, \"getOSType\", GetOSType); env-&gt;SetMethod(target, \"getOSRelease\", GetOSRelease); env-&gt;SetMethod(target, \"getInterfaceAddresses\", GetInterfaceAddresses); env-&gt;SetMethod(target, \"getHomeDirectory\", GetHomeDirectory); env-&gt;SetMethod(target, \"getUserInfo\", GetUserInfo); env-&gt;SetMethod(target, \"setPriority\", SetPriority); env-&gt;SetMethod(target, \"getPriority\", GetPriority); target-&gt;Set(FIXED_ONE_BYTE_STRING(env-&gt;isolate(), \"isBigEndian\"), Boolean::New(env-&gt;isolate(), IsBigEndian()));&#125;&#125; // namespace os&#125; // namespace nodeNODE_BUILTIN_MODULE_CONTEXT_AWARE(os, node::os::Initialize) 这个 os 模块先是定义了一些函数，代码最后一行是个宏调用，这个宏把模块名 os 和 Initialize 函数做为其参数，我们找到它的定义如下： 123/* src/node_internals.h:169 */#define NODE_BUILTIN_MODULE_CONTEXT_AWARE(modname, regfunc) \\ NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, nullptr, NM_F_BUILTIN) 又是一个宏定义，继续跟下去：12345678910111213141516/* src/node_internals.h:152*/#define NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags) \\ static node::node_module _module = &#123; \\ NODE_MODULE_VERSION, \\ flags, \\ nullptr, \\ __FILE__, \\ nullptr, \\ (node::addon_context_register_func) (regfunc), \\ NODE_STRINGIFY(modname), \\ priv, \\ nullptr \\ &#125;; \\ void _register_ ## modname() &#123; \\ node_module_register(&amp;_module); \\ &#125; 这个宏的定义里好像看到了我们要找的代码，我们在这里就可以把 NODE_BUILTIN_MODULE_CONTEXT_AWARE(os, node::os::Initialize) 完全展开了： 1234567891011121314151617// 创建一个 node_module 对象 _modulestatic node::node_module _module = &#123; NODE_MODULE_VERSION, NM_F_BUILTIN, nullptr, __FILE__, nullptr, (node::addon_context_register_func) (node::os::Initialize), NODE_STRINGIFY(os), nullptr, nullptr&#125;;// 定义我们要找的 _register_os() 函数void _register_os() &#123; node_module_register(&amp;_module); &#125; 到此，我们就明白了 RegisterBuiltinModules() 函数中调用的 _register_os() 是在哪里定义的了，随后查看了所有原生模块的代码，最后一行都是以同样的方式定义相应的 _register_xx()。 其中 node::node_module 类型就代表一个模块的信息。 所谓注册 os 模块实际是调用了 node_module_register(node_module *) 函数完成的，我们继续来看看 node_module_register() 函数和 node::node_module： 模块注册实现12345678910111213/* src/node.h:518*/struct node_module &#123; int nm_version; unsigned int nm_flags; void* nm_dso_handle; const char* nm_filename; // 上例中 Initialize 函数被赋到 nm_register_func 里 node::addon_register_func nm_register_func; node::addon_context_register_func nm_context_register_func; const char* nm_modname; // 模块的名字 void* nm_priv; struct node_module* nm_link; &#125;; 12345678910111213141516171819202122/* src/node.cc:1094 */extern \"C\" void node_module_register(void* m) &#123; struct node_module* mp = reinterpret_cast&lt;struct node_module*&gt;(m); if (mp-&gt;nm_flags &amp; NM_F_BUILTIN) &#123; // 链表操作 mp-&gt;nm_link = modlist_builtin; modlist_builtin = mp; &#125; else if (mp-&gt;nm_flags &amp; NM_F_INTERNAL) &#123; // 链表操作 mp-&gt;nm_link = modlist_internal; modlist_internal = mp; &#125; else if (!node_is_initialized) &#123; // \"Linked\" modules are included as part of the node project. // Like builtins they are registered *before* node::Init runs. mp-&gt;nm_flags = NM_F_LINKED; mp-&gt;nm_link = modlist_linked; modlist_linked = mp; &#125; else &#123; uv_key_set(&amp;thread_local_modpending, mp); &#125;&#125; 到这里就清晰了， 所谓原生模块的注册，实际上就是将一个类型为 node::node_module 的模块对象，添加到不同类别的全局链表中。 上述代码中用3个全局链表：modlist_builtin modlist_internal modlist_linked 分别保存不同类型的模块，本文我们说的是 BUILTIN 类型的，也就是第一个。 我把这几个链表的定义位置发出来： 12345/* src/node.cc:175 */static node_module* modlist_builtin; // 我们现在只关注 builtin 模块static node_module* modlist_internal;static node_module* modlist_linked;static node_module* modlist_addon; 小结这个原生模块的注册过程就写到这里，逻辑还是比较简单的，只是连续的宏定义让代码不那么直观。 原生模块加载写完后，接下来，会继续写原生模块的加载篇。","categories":[{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"https://laogen.site/categories/Node-js-源码分析/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://laogen.site/tags/Node-js/"},{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"https://laogen.site/tags/Node-js-源码分析/"},{"name":"源码分析","slug":"源码分析","permalink":"https://laogen.site/tags/源码分析/"}]},{"title":"Node.js 源码分析 - 从 main 函数开始","slug":"nodejs/nodejs-src/the-main","date":"2018-11-27T13:30:15.000Z","updated":"2019-02-11T14:15:38.483Z","comments":true,"path":"nodejs/nodejs-src/the-main/","link":"","permalink":"https://laogen.site/nodejs/nodejs-src/the-main/","excerpt":"小目标 知道程序大概执行逻辑，关键点执行的顺序 我们平时在终端敲下 node app.js 后，发生了什么。 具体点，知道 node.js 原生(C++)模块什么时候加载的，在哪加载的;知道我们的 js 代码是在哪个环节被加载执行的；知道进程的主循环（事件循环）什么时候启动的； 有了这个小目标的基础，在接下来的文章中，我们再进一步的探索 node.js 原生模块的注册是怎么实现的，怎么获取 &amp; 初始化的，怎么曝露给 js 环境调用的；再细说 node.js 的模块机制，我们通常的 app.js 怎么被执行的；","text":"小目标 知道程序大概执行逻辑，关键点执行的顺序 我们平时在终端敲下 node app.js 后，发生了什么。 具体点，知道 node.js 原生(C++)模块什么时候加载的，在哪加载的;知道我们的 js 代码是在哪个环节被加载执行的；知道进程的主循环（事件循环）什么时候启动的； 有了这个小目标的基础，在接下来的文章中，我们再进一步的探索 node.js 原生模块的注册是怎么实现的，怎么获取 &amp; 初始化的，怎么曝露给 js 环境调用的；再细说 node.js 的模块机制，我们通常的 app.js 怎么被执行的； 贴代码说明限于篇幅，本文只先把大体执行流程捋出来，后面再开文一块块的捋。 原代码太长，先把不影响我们分析的无关代码去掉，贴上来有关整体执行逻辑的代码，代码中的 // ... 注释意思是这个地方有被省略的代码。 每段代码第一行的注释都会指出源文件位置，一些代码讲解会在代码段中的注释中进行； 本文不再介绍 V8 和 Libuv 的知识，会开专门的分类写 V8 和 Libuv，参考 Node.js 源码分析 - 前言 开捋：从 main 函数到进程主循环main 函数12345/* src/node_main.cc:93 */int main(int argc, char* argv[]) &#123; // ... return node::Start(argc, argv);&#125; main函数 在 src/node_main.cc 这个文件中，这个文件主要就是存放 main函数。 很简单，只是调用了 node::Start()，这个函数在 src/node.cc 这个文件中，接下来的核心代码都在这个文件中。 初始化 V8 引擎123456789101112131415161718192021222324/* src/node.cc:3011 */int Start(int argc, char** argv) &#123; // ... std::vector&lt;std::string&gt; args(argv, argv + argc); std::vector&lt;std::string&gt; exec_args; // This needs to run *before* V8::Initialize(). Init(&amp;args, &amp;exec_args); // ... v8_platform.Initialize(per_process_opts-&gt;v8_thread_pool_size); V8::Initialize(); // ... const int exit_code = Start(uv_default_loop(), args, exec_args); v8_platform.StopTracingAgent(); v8_initialized = false; V8::Dispose(); v8_platform.Dispose(); return exit_code;&#125; 在这段代码，首先进行 V8 的初始化，然后调用了另外一个 Start(uv_loop_t*, ...)函数，最后释放资源，进程结束； 其中值得注意的一点，在初始化 V8 之前，调用了一个 Init() 函数，这个函数主要完成了 Node.js 原生(C++)模块的注册，就是 fs http等模块的 C++ 实现模块。 1234567/* src/node.cc:2559 */void Init(std::vector&lt;std::string&gt;* argv, std::vector&lt;std::string&gt;* exec_argv) &#123; // ... // Register built-in modules RegisterBuiltinModules(); // ...&#125; Init() 中调用了 RegisterBuiltinModules()，它注册了所有 Node.js 原生模块，关于原生模块的注册，本文不再继续跟进去，下一篇会单独展开这一块，这里先知道这个流程。 记住这个 RegisterBuiltinModules()，下一篇文章就从这里开始展开。 创建 Isolate 实例12345678910111213141516171819202122/* src/node.cc:2964 */inline int Start(uv_loop_t* event_loop, const std::vector&lt;std::string&gt;&amp; args, const std::vector&lt;std::string&gt;&amp; exec_args) &#123; std::unique_ptr&lt;ArrayBufferAllocator, decltype(&amp;FreeArrayBufferAllocator)&gt; allocator(CreateArrayBufferAllocator(), &amp;FreeArrayBufferAllocator); // 创建 Isolate 实例 Isolate* const isolate = NewIsolate(allocator.get()); // ... int exit_code; &#123; Locker locker(isolate); Isolate::Scope isolate_scope(isolate); HandleScope handle_scope(isolate); // ... exit_code = Start(isolate, isolate_data.get(), args, exec_args); &#125; // ... isolate-&gt;Dispose(); return exit_code;&#125; 这个 Start() 倒也没做什么，主要工作是创建了 Isolate 实例，然后调用了另外一个 Start(Isolate*...)。 进程主循环1234567891011121314151617181920212223242526272829303132333435363738394041/* src/node.cc:2868 */inline int Start(Isolate* isolate, IsolateData* isolate_data, const std::vector&lt;std::string&gt;&amp; args, const std::vector&lt;std::string&gt;&amp; exec_args) &#123; HandleScope handle_scope(isolate); // 创建 V8 Context 对象 Local&lt;Context&gt; context = NewContext(isolate); Context::Scope context_scope(context); // 创建 Environment 对象，这个是 Node.js 的类 Environment env(isolate_data, context, v8_platform.GetTracingAgentWriter()); // 这里面主要完成 libuv 的初始化，以及创建 process 对象 // 就是 Node.js 中那个全局的 process 对象，这里不细展开 env.Start(args, exec_args, v8_is_profiling); &#123; // ... // LoadEnvironment 是本文重要的关键点 LoadEnvironment(&amp;env); env.async_hooks()-&gt;pop_async_id(1); &#125; // 下面就是进程的主循环 &#123; // ... bool more; // ... do &#123; uv_run(env.event_loop(), UV_RUN_DEFAULT); // ... more = uv_loop_alive(env.event_loop()); if (more) continue; // ... &#125; while (more == true); &#125; // ... return exit_code;&#125; 这段代码创建并使用了 js 执行需要的 context，然后创建了 Environment 对象； 这个 Environment 对象是 Node.js 源码中重要的一个对象，它是一个全局单例，定义和存储了一些重要的全局对象和函数，比如刚开始创建的 Isolate 对象、刚刚创建的 Context 对象等，注意它不是 V8 的，是 Node.js 定义的，对它的使用贯穿整个 Node.js 执行的生命周期。 再下面是进程的主循环，uv_run() 启动了 Libuv 的事件循环， 它也是 Node.js 进程的主循环，Libuv 会单独写文介绍。 最后说一下，中间的 LoadEnvironment() 调用，它是在程序进入主循环之前最关键的一环； LoadEnvironment() 完成了一些 js 文件的加载和执行，其中就包括加载执行通常编写的 app.js。 主循环之前1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* src/node.cc:2115 */void LoadEnvironment(Environment* env) &#123; HandleScope handle_scope(env-&gt;isolate()); // ... // The bootstrapper scripts are lib/internal/bootstrap/loaders.js and // lib/internal/bootstrap/node.js, each included as a static C string // defined in node_javascript.h, generated in node_javascript.cc by // node_js2c. // 加载两个重要的 js 文件：internal/bootstrap/loaders.js // 和 internal/bootstrap/node.js Local&lt;String&gt; loaders_name = FIXED_ONE_BYTE_STRING(env-&gt;isolate(), \"internal/bootstrap/loaders.js\"); MaybeLocal&lt;Function&gt; loaders_bootstrapper = GetBootstrapper(env, LoadersBootstrapperSource(env), loaders_name); Local&lt;String&gt; node_name = FIXED_ONE_BYTE_STRING(env-&gt;isolate(), \"internal/bootstrap/node.js\"); MaybeLocal&lt;Function&gt; node_bootstrapper = GetBootstrapper(env, NodeBootstrapperSource(env), node_name); // ... // Add a reference to the global object Local&lt;Object&gt; global = env-&gt;context()-&gt;Global(); env-&gt;SetMethod(env-&gt;process_object(), \"_rawDebug\", RawDebug); // Expose the global object as a property on itself // (Allows you to set stuff on `global` from anywhere in JavaScript.) global-&gt;Set(FIXED_ONE_BYTE_STRING(env-&gt;isolate(), \"global\"), global); // 准备 binding 函数，下面调用 js 会作为参数传给 js 环境 // Create binding loaders Local&lt;Function&gt; get_binding_fn = env-&gt;NewFunctionTemplate(GetBinding)-&gt;GetFunction(env-&gt;context()) .ToLocalChecked(); Local&lt;Function&gt; get_linked_binding_fn = env-&gt;NewFunctionTemplate(GetLinkedBinding)-&gt;GetFunction(env-&gt;context()) .ToLocalChecked(); Local&lt;Function&gt; get_internal_binding_fn = env-&gt;NewFunctionTemplate(GetInternalBinding)-&gt;GetFunction(env-&gt;context()) .ToLocalChecked(); // 准备执行 internal/bootstrap/loaders.js 文件的参数 Local&lt;Value&gt; loaders_bootstrapper_args[] = &#123; env-&gt;process_object(), get_binding_fn, get_linked_binding_fn, get_internal_binding_fn, Boolean::New(env-&gt;isolate(), env-&gt;options()-&gt;debug_options-&gt;break_node_first_line) &#125;; // 执行 internal/bootstrap/loaders.js // Bootstrap internal loaders // 这个对象是用来接收执行结果的，记住是 bootstrapped_loaders，下面会用到 Local&lt;Value&gt; bootstrapped_loaders; if (!ExecuteBootstrapper(env, loaders_bootstrapper.ToLocalChecked(), arraysize(loaders_bootstrapper_args), loaders_bootstrapper_args, &amp;bootstrapped_loaders)) &#123; return; &#125; // 准备执行 internal/bootstrap/node.js 的参数 // Bootstrap Node.js Local&lt;Object&gt; bootstrapper = Object::New(env-&gt;isolate()); SetupBootstrapObject(env, bootstrapper); Local&lt;Value&gt; bootstrapped_node; Local&lt;Value&gt; node_bootstrapper_args[] = &#123; env-&gt;process_object(), bootstrapper, // 注意，这里是上面执行 loaders.js 返回的结果对象， // 作为执行参数传给 internal/bootstrap/node.js bootstrapped_loaders &#125;; // 执行 internal/bootstrap/node.js if (!ExecuteBootstrapper(env, node_bootstrapper.ToLocalChecked(), arraysize(node_bootstrapper_args), node_bootstrapper_args, &amp;bootstrapped_node)) &#123; return; &#125;&#125; LoadEnvironment() 首先加载了两个 js 文件，这两个 js 文件的位置分别在：lib/internal/bootstrap/loaders.js 和 lib/internal/bootstrap/node.js。 我们 Node.js 开发者写的 app.js 其实就是在这两个 js 文件中加载并执行的，这块是最重要的逻辑之一，内容也很多，后面的文章会详细展开。 LoadEnvironment() 接下来创建了三个 binding 函数： get_binding_fn get_linked_binding_fn get_internal_binding_fn 这3个 binding 函数是用来获取和加载 Node.js 原生模块的，会传入到 js 执行环境中，也就是你在 js 代码中是可以调用的，比如 process.binding(&#39;fs&#39;)，在我们用 C++ 开发 Node.js 扩展模块的时候，也会用到，以后会详细展开。 LoadEnvironment() 接下来要执行 lib/internal/bootstrap/loaders.js，在这个 js 文件中主要定义了内部(internal)模块加载器(loaders)。 lib/internal/bootstrap/loaders.js 定义的模块加载器(loaders) 接下来做为执行参数，传入了 lib/internal/bootstrap/node.js，在 lib/internal/bootstrap/node.js 中会使用这些 loaders 来加载 internal 模块。 lib/internal/bootstrap/node.js 做了很多工作，这里只需要知道，它最终加载并执行了我们 Node.js 程序员编写的 app.js 就可以了。 到此为止，我们就知道了在命令行敲下 node app.js 大概发生了哪些事！ 小结这只是个大概逻辑，可以配合 Node.js 源码，再花时间捋一捋，光靠贴的这点代码，可能还是会迷糊的。 接下来的文章，就是对这个执行逻辑中的关键点分别展开。 作者水平有限，写的也仓促，有误之处还请指出。","categories":[{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"https://laogen.site/categories/Node-js-源码分析/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://laogen.site/tags/Node-js/"},{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"https://laogen.site/tags/Node-js-源码分析/"},{"name":"源码分析","slug":"源码分析","permalink":"https://laogen.site/tags/源码分析/"}]},{"title":"Node.js 源码分析 - 目录 & 前言","slug":"nodejs/nodejs-src/index","date":"2018-11-24T14:30:15.000Z","updated":"2019-02-21T07:40:05.415Z","comments":true,"path":"nodejs/nodejs-src/index/","link":"","permalink":"https://laogen.site/nodejs/nodejs-src/index/","excerpt":"这两年先后两次读过 Node.js 源码，但是每次都懒于记录，过几个月就忘记了，这次把疏理过程记录下来，以免之后再浪费时间从头看。虽然是为了备忘，我会尽量站在读者的角度写，以望能帮助想了解 Node.js 源码的朋友节省一些时间、精力。 适合谁- 你需要熟悉 C/C++ - 你需要熟悉 Node.js，理解异步编程及原理","text":"这两年先后两次读过 Node.js 源码，但是每次都懒于记录，过几个月就忘记了，这次把疏理过程记录下来，以免之后再浪费时间从头看。虽然是为了备忘，我会尽量站在读者的角度写，以望能帮助想了解 Node.js 源码的朋友节省一些时间、精力。 适合谁- 你需要熟悉 C/C++ - 你需要熟悉 Node.js，理解异步编程及原理 目录 持续更新中 -&gt; V8 Embedding Js Engine V8 Embedding - 编译 Js Engine V8 Embedding - Hello World 讲解 Js Engine V8 Embedding - C++ 变量暴露给 Javascript 环境 Js Engine V8 Embedding - C++ 函数暴露给 Javascript 环境 Js Engine V8 Embedding - V8 函数传参、返回、异常处理 Js Engine V8 Embedding - 回调函数 -&gt; Node.js 源码分析 从 main 函数开始 原生模块的注册 分析方式根据执行流程，直接从 main 函数开始走， 然后再单独分析具体模块。 疏理执行逻辑是这次分析的重点。 代码我使用的版本是 node.js 仓库里 v10.x 分支。 123git clone git@github.com:nodejs/node.git cd nodegit checkout v10.x 相关资料 Libuv 官网 User Guide 很友好：http://docs.libuv.org/en/v1.x/guide.html Node.js 源码：https://github.com/nodejs/node Node.js 源码构建：https://github.com/nodejs/node/blob/master/BUILDING.md V8 构建：https://v8.dev/docs/build V8 Embedding: https://v8.dev/docs/embed","categories":[{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"https://laogen.site/categories/Node-js-源码分析/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://laogen.site/tags/Node-js/"},{"name":"Node.js 源码分析","slug":"Node-js-源码分析","permalink":"https://laogen.site/tags/Node-js-源码分析/"},{"name":"源码分析","slug":"源码分析","permalink":"https://laogen.site/tags/源码分析/"}]},{"title":"动手写一个简单的 Promise.js","slug":"javascript/diy-simple-promise-js","date":"2018-11-23T18:07:14.000Z","updated":"2018-11-23T19:00:16.701Z","comments":true,"path":"javascript/diy-simple-promise-js/","link":"","permalink":"https://laogen.site/javascript/diy-simple-promise-js/","excerpt":"初学 Node.js 的朋友总会耗一番周折去理解 Promise，这里给出一个最简单的 Promise 实现，以帮助对 Promise 还有疑惑的同学彻底理解其实现原理。","text":"初学 Node.js 的朋友总会耗一番周折去理解 Promise，这里给出一个最简单的 Promise 实现，以帮助对 Promise 还有疑惑的同学彻底理解其实现原理。 这个代码应该是三年前我刚接触 Node.js 的时候写的了，当时也是 Google 不少关于 Promise 的文章，现在已经不记得相关链接了。 这个并不是完整的 Promise 逻辑，旨在理解 Promise 的实现原理，由于过了太久，我就直接贴出来代码不做解释说明了。如果先前有用过 Promise 的话，应该还是较容易理解的； 若是初接触，这个逻辑还是有点绕，先去其它地方了解 Promse 的用法，再多花点时间去理一理这段代码，是值得的。 12345678910111213141516171819202122232425262728293031323334353637383940// Promisefunction Promise(fn) &#123; var self = this self.state = 'PENDING' self.onFulfilled = null self.onRejected = null self.then = function (onResolved, onRejected) &#123; var that = this; return new Promise(function (resolve, reject) &#123; that.onFulfilled = function (val) &#123; var ret = onResolved ? onResolved(val) : val; if (ret &amp;&amp; ret.then) &#123; ret.then(function (val) &#123; resolve(val) &#125;) &#125; else &#123; resolve(ret); &#125; &#125;; that.onRejected = function (val) &#123; var ret = onRejected ? onRejected(val) : val; reject(ret); &#125;; &#125;); &#125; fn &amp;&amp; fn(function (result) &#123; if (self.state === 'PENDING') &#123; self.state = 'FULFILLED'; setTimeout(function()&#123; self.onFulfilled &amp;&amp; self.onFulfilled(result); &#125;,0) &#125; &#125;, function (reason) &#123; if (self.state === 'PENDING') &#123; self.state = 'REJECTED'; self.onRejected &amp;&amp; self.onRejected(reason); &#125; &#125;);&#125; 使用示例：12345678910111213function sleep(t) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function () &#123; console.log(t) resolve(t) &#125;, t) &#125;)&#125;sleep(1000) .then(data =&gt; sleep(data + 1)) .then(data =&gt; sleep(data + 1)) .then(data =&gt; sleep(data + 1))","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://laogen.site/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laogen.site/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"https://laogen.site/tags/promise/"}]},{"title":"GitLab CI 示例：构建 & 部署 Web 前端项目（部署到 Swarm）","slug":"gitlab-ci/example-web-front-end","date":"2018-11-22T01:51:04.000Z","updated":"2018-12-28T11:16:20.539Z","comments":true,"path":"gitlab-ci/example-web-front-end/","link":"","permalink":"https://laogen.site/gitlab-ci/example-web-front-end/","excerpt":"问题Web 前端的应用需要在 node 环境下安装依赖和构建，但是发布一般又是用 nginx 镜像，我们既不想在 node 容器里安装 nginx，也不想在 nginx 容器里安装 node； TL;DR所以，我们先在一个 node 容器中 build 应用，利用 GitLab CI Cache 机制，将构建后的目标文件（通常是 dist 文件夹）缓存，以便在发布阶段 (release stage) 可以使用。 这里我所谓的 release 是指发布 docker image ，所以需要一个 Dockerfile，并且是以 nginx image 为基础镜像构建的。 我这里是部署到 swarm 集群上，所以会首先把 docker-stack.yml 文件 scp 到目标服务器上。","text":"问题Web 前端的应用需要在 node 环境下安装依赖和构建，但是发布一般又是用 nginx 镜像，我们既不想在 node 容器里安装 nginx，也不想在 nginx 容器里安装 node； TL;DR所以，我们先在一个 node 容器中 build 应用，利用 GitLab CI Cache 机制，将构建后的目标文件（通常是 dist 文件夹）缓存，以便在发布阶段 (release stage) 可以使用。 这里我所谓的 release 是指发布 docker image ，所以需要一个 Dockerfile，并且是以 nginx image 为基础镜像构建的。 我这里是部署到 swarm 集群上，所以会首先把 docker-stack.yml 文件 scp 到目标服务器上。 例说1234# DockerfileFROM bitnami/nginx:latestCOPY ./dist /appEXPOSE 8080 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# .gitlab-ci.ymlimage: node:10stages: - build - release - deploycache: paths: - node_modules/ - dist/before_script: - if [ $CI_COMMIT_REF_NAME = master ];then export SERVER_HOST=$DEV_SERVER_HOST;fi - if [ $CI_COMMIT_REF_NAME = prod ];then export SERVER_HOST=$PROD_SERVER_HOST;fi - if [ $CI_COMMIT_REF_NAME = master ];then export BUILD_VERSION=dev;fi - if [ $CI_COMMIT_REF_NAME = prod ];then export BUILD_VERSION=prod;fivariables: CONTAINER_IMAGE: $REGISTRY_ADDR/$REGISTRY_NAMESPACE/$CI_PROJECT_NAME CONTAINER_IMAGE_VERSION: \"$&#123;CI_COMMIT_REF_NAME&#125;_latest\" CONTAINER_IMAGE_VERSION_HASH: \"$&#123;CI_COMMIT_REF_NAME&#125;_$&#123;CI_COMMIT_SHA&#125;\" DOCKER_DRIVER: overlay2build: stage: build script: - npm install - npm run build:$BUILD_VERSIONrelease: image: docker:dind stage: release script: - ls -lh dist - docker login -u $REGISTRY_USER -p $REGISTRY_PASSWORD $REGISTRY_ADDR - docker pull $CONTAINER_IMAGE:$CONTAINER_IMAGE_VERSION || true - docker build --cache-from $CONTAINER_IMAGE:$CONTAINER_IMAGE_VERSION --tag $CONTAINER_IMAGE:$CONTAINER_IMAGE_VERSION_HASH --tag $CONTAINER_IMAGE:$CONTAINER_IMAGE_VERSION . - docker push $CONTAINER_IMAGE:$CONTAINER_IMAGE_VERSION - docker push $CONTAINER_IMAGE:$CONTAINER_IMAGE_VERSION_HASHdeploy: image: laogen/openssh-client:latest stage: deploy script: - eval $(ssh-agent -s) - echo \"$SERVER_SSH_PRIV_KEY\" &gt; deploy.key - mkdir -p ~/.ssh - chmod 0600 deploy.key - ssh-add deploy.key - '[[ -f /.dockerenv ]] &amp;&amp; echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" &gt; ~/.ssh/config' - scp docker-stack.$&#123;BUILD_VERSION&#125;.yml root@$SERVER_HOST:/srv/web/docker-stack.yml - ssh root@$SERVER_HOST \"docker login -u $REGISTRY_USER -p $REGISTRY_PASSWORD $REGISTRY_ADDR\" - ssh root@$SERVER_HOST \"cd /srv/web &amp;&amp; docker stack deploy -c docker-stack.yml ProjectName --with-registry-auth\" 小结这个例子是从实际工作项目中略删减得来的，更完整综合一些。 这个 Pipeline 一共三个阶段： build # 构建前端项目 release # 发布 Docker 镜像 deploy # 部署到 Swarm 上 在 build 阶段完成后，将 build 的结果 dist 缓存起来，这样到 realse 阶段时，就可以把它们打包到镜像里了，然后 push 到镜像仓库； deploy 阶段就是 ssh 连接远程执行命令部署，与之前不同的是，这次是部署在 swarm 上，我们先将 docker-stack.yml 上传到目标服务器，然后远程执行部署指令，这块没什么可说的。","categories":[{"name":"GitLab CI/CD","slug":"GitLab-CI-CD","permalink":"https://laogen.site/categories/GitLab-CI-CD/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://laogen.site/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"https://laogen.site/tags/gitlab-ci/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://laogen.site/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","permalink":"https://laogen.site/tags/DevOps/"}]},{"title":"GitLab CI 示例：利用 CI 同步生产环境数据库到开发环境","slug":"gitlab-ci/example-db-sync","date":"2018-11-20T12:58:19.000Z","updated":"2018-12-15T00:13:25.660Z","comments":true,"path":"gitlab-ci/example-db-sync/","link":"","permalink":"https://laogen.site/gitlab-ci/example-db-sync/","excerpt":"问题我们通常需要频繁的将生产环境(production)的数据库同步到 develop 和 staging 环境。 之前我们的做法是写了一个 shell 在服务器上手动运行，这个需要测试人员和开发人员拥有服务器权限，甚至是生产环境的权限，风险较大且 “不够 CI/CD 化”。 后来是想写一个 HTTP 服务来触发这样的数据库同步操作，增加了额外的工作开销，还要为这个服务配相应的 CI/CD，不如直接使用 GitLab CI 来完成这个工作。 GitLab CI Pipeline 不仅可以在用户 push 代码的时候被触发，还可以通过 HTTP 调用的形式主动触发。 目标开发 &amp; 测试人员将 production 环境的数据库同步到 develop / staging 环境： - 无需接触服务器环境 - 任意时间可主动进行同步（相对于计划任务而言） - 可指定同步某个项目相关的数据库 - 可指定同步到某个服务器环境 ( develop / staging ) 预设场景： - 有三个数据库项目：project-a project-b project-c - 有三个服务器环境：production develop staging - 通过 GitLab CI Pipeline Triggers 来触发执行(HTTP方式) - 我们可任意指定同步某一个项目的 production 数据库到 develop 或 staging","text":"问题我们通常需要频繁的将生产环境(production)的数据库同步到 develop 和 staging 环境。 之前我们的做法是写了一个 shell 在服务器上手动运行，这个需要测试人员和开发人员拥有服务器权限，甚至是生产环境的权限，风险较大且 “不够 CI/CD 化”。 后来是想写一个 HTTP 服务来触发这样的数据库同步操作，增加了额外的工作开销，还要为这个服务配相应的 CI/CD，不如直接使用 GitLab CI 来完成这个工作。 GitLab CI Pipeline 不仅可以在用户 push 代码的时候被触发，还可以通过 HTTP 调用的形式主动触发。 目标开发 &amp; 测试人员将 production 环境的数据库同步到 develop / staging 环境： - 无需接触服务器环境 - 任意时间可主动进行同步（相对于计划任务而言） - 可指定同步某个项目相关的数据库 - 可指定同步到某个服务器环境 ( develop / staging ) 预设场景： - 有三个数据库项目：project-a project-b project-c - 有三个服务器环境：production develop staging - 通过 GitLab CI Pipeline Triggers 来触发执行(HTTP方式) - 我们可任意指定同步某一个项目的 production 数据库到 develop 或 staging 首先，我们建了一个新的 GitLab Repo，可以叫作 db-sync，并开始配置其 CI Pipeline。 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# .gitlab-ci.ymlstages: - dump - upload - restorebefore_script: - if [ $TO = dev ];then export SERVER_HOST=$DEV_SERVER_HOST;fi - if [ $TO = stg ];then export SERVER_HOST=$STG_SERVER_HOST;fi - if [ $PROJECT = project-a ];then export MONGO_DB=project-a-db;fi - if [ $PROJECT = project-b ];then export MONGO_DB=project-b-db;fi - if [ $PROJECT = project-c ];then export MONGO_DB=project-c-db;fi cache: paths: - tmp_datadump_db: image: mongo:latest stage: dump script: - rm -rf tmp_data || true - mkdir tmp_data || true - &gt; mongodump -h $MONGO_HOST --port=$MONGO_PORT -u $MONGO_USER -p $MONGO_PASSWORD -d $MONGO_DB --out=tmp_data - cd tmp_data/$MONGO_DB &amp;&amp; tar -zcvf ./../data.tar.gz ./* only: variables: - $PROJECT - $TOupload_db: image: laogen/openssh-client:latest stage: upload script: - eval $(ssh-agent -s) - echo \"$SERVER_SSH_PRIV_KEY\" &gt; deploy.key - mkdir -p ~/.ssh - chmod 0600 deploy.key - ssh-add deploy.key - '[[ -f /.dockerenv ]] &amp;&amp; echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" &gt; ~/.ssh/config' - ssh root@$SERVER_HOST \"rm -rf /srv/db-data/$PROJECT/_data/ || true\" - ssh root@$SERVER_HOST \"rm -rf /srv/db-data/$PROJECT/data.tar.gz || true\" - scp tmp_data/data.tar.gz root@$SERVER_HOST:/srv/db-data/$PROJECT/data.tar.gz - ssh root@$SERVER_HOST \"mkdir -p /srv/db-data/$PROJECT/_data || true\" - ssh root@$SERVER_HOST \"tar zxvf /srv/db-data/$PROJECT/data.tar.gz -C /srv/db-data/$PROJECT/_data\" only: variables: - $PROJECTrestore: image: laogen/openssh-client:latest stage: restore script: - eval $(ssh-agent -s) - echo \"$SERVER_SSH_PRIV_KEY\" &gt; deploy.key - mkdir -p ~/.ssh - chmod 0600 deploy.key - ssh-add deploy.key - '[[ -f /.dockerenv ]] &amp;&amp; echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" &gt; ~/.ssh/config' - scp restore.sh root@$SERVER_HOST:/srv/db-bak/$PROJECT/restore.sh - export CONTAINER_ID='$(docker ps -f name='$PROJECT' -f ancestor=bitnami/mongodb -q)' - ssh root@$SERVER_HOST \"docker exec $CONTAINER_ID sh /bitnami/restore.sh\" only: variables: - $TO - $PROJECT 这个 Pipeline 有三个 stages： - dump 从 prod 数据库中把数据导出为文件 - upload 将数据文件上传到 dev/stg 目标服务器 - restore 通过 ssh 远程连接到目标服务器，将数据文件导入(restore)到 mongo 中 其中涉及的 ssh 等操作前文具体讲过，不了解的话可移步 GitLab CI 示例：Docker 镜像打包发布 & SSH 部署。 这段 CI 脚本是我在实际工作中使用的，其中 mongodb 是使用 bitnami/mongodb 镜像启动的，所以会有 bitnami 相关的字眼，需要了解的话请查看文末的相关链接。 如果使用其它 mongo 镜像或者其它数据库（ mysql 等）需要做相应的调整，这里只是提供一个思路作为参考。 restore.sh 这个文件在 git repo中，它被挂载到数据库容器中执行的：12# restore.shmongorestore --drop -u $MONGODB_USERNAME -p $MONGODB_PASSWORD -d $MONGODB_DATABASE /bitnami/_data 触发同步我们通过 $PROJECT 来控制要同步哪个项目的数据库；通过 $TO 控制要同步到哪个服务器环境(develop / staging)。 12345# 同步 project-a 项目的数据库到 dev 环境curl -X POST -F token=XXXXXXX \\ -F ref=master -F \"variables[TO]=dev\" \\ -F \"variables[PROJECT]=project-a\" \\ https://gitlab.com/api/v4/projects/xxxxxx/trigger/pipeline 12345# 同步 project-b 项目的数据库到 stg 环境curl -X POST -F token=XXXXXXX \\ -F ref=master -F \"variables[TO]=stg\" \\ -F \"variables[PROJECT]=project-b\" \\ https://gitlab.com/api/v4/projects/xxxxxx/trigger/pipeline 我们通过 GitLab CI 的 HTTP 触发机制触发 Pipeline 的执行。其中 token 和 url 在 GitLab 仓库的设置页面获取 Settings &gt; CI/CD &gt; Pipeline triggers &gt; Add trigger，该页面中有详情的使用说明。 小结上面触发的例子是通过 curl 发送请求完成的，也可以使用 Webhook 的方式，这样可以把请求链接加入到浏览器的书签中，需要同步数据库的时候，直接打开相应的书签即可快捷完成。 这种方式不仅可以用来同步数据库，还可以用来同步其它生产环境的数据，比如文件资源等。 同时，除去用来同步数据，也可用于备份数据等工作。 相关链接 bitnami/mongodb: https://github.com/bitnami/bitnami-docker-mongodb MongoDB 备份(mongodump)与恢复(mongorestore)http://www.runoob.com/mongodb/mongodb-mongodump-mongorestore.html","categories":[{"name":"GitLab CI/CD","slug":"GitLab-CI-CD","permalink":"https://laogen.site/categories/GitLab-CI-CD/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://laogen.site/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"https://laogen.site/tags/gitlab-ci/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://laogen.site/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","permalink":"https://laogen.site/tags/DevOps/"}]},{"title":"GitLab CI 示例：Docker 镜像打包发布 & SSH 部署","slug":"gitlab-ci/example-docker-ssh-deploy","date":"2018-11-18T13:44:35.000Z","updated":"2018-12-11T02:20:48.861Z","comments":true,"path":"gitlab-ci/example-docker-ssh-deploy/","link":"","permalink":"https://laogen.site/gitlab-ci/example-docker-ssh-deploy/","excerpt":"目标当我们 push 代码到 git 仓库时，将项目部署到目标服务器上，具体步骤： - 基于代码仓库中的 Dockerfile 构建代码镜像 - 将构建的代码镜像推送到我们的私有镜像仓库 - 通过 ssh 连接目标服务器，远程执行部署指令，基于代码镜像启动容器","text":"目标当我们 push 代码到 git 仓库时，将项目部署到目标服务器上，具体步骤： - 基于代码仓库中的 Dockerfile 构建代码镜像 - 将构建的代码镜像推送到我们的私有镜像仓库 - 通过 ssh 连接目标服务器，远程执行部署指令，基于代码镜像启动容器 示例代码说明1234567891011121314151617181920212223242526272829stages: - build - deployvariables: TARGET_IMAGE: $REGISTRY_ADDR/maslow/ci-example-app:latest DOCKER_DRIVER: overlay2build: image: docker:stable stage: build script: - docker login -u $REGISTRY_USER -p $REGISTRY_PASSWORD $REGISTRY_ADDR - docker pull $TARGET_IMAGE || true # for docker build caching - docker build --cache-from $TARGET_IMAGE --tag $TARGET_IMAGE . - docker push $TARGET_IMAGEdeploy: image: ubuntu:latest stage: deploy script: - 'which ssh-agent || (apt-get update -y &amp;&amp; apt-get install openssh-client -y)' - eval $(ssh-agent -s) - echo \"$SERVER_SSH_PRIV_KEY\" &gt; deploy.key - mkdir -p ~/.ssh - chmod 0600 deploy.key - ssh-add deploy.key - '[[ -f /.dockerenv ]] &amp;&amp; echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" &gt; ~/.ssh/config' - ssh root@$SERVER_ADDR \"docker run -d -P $&#123;TARGET_IMAGE&#125;\" 这段 CI 脚本有两个 stage: - build # 根据代码目录下的 Dockerfile 构建镜像，并 push 到镜像仓库 - deploy # 通过 ssh 连接目标服务器，远程执行部署指令 其中用到了一些预定义了一些环境变量： - REGISTRY_ADDR # 私有镜像仓库的地址，例如：registry.cn-hangzhou.aliyuncs.com - REGISTRY_USER # 私有镜像仓库用户名 - REGISTRY_PASSWORD # 私有镜像仓库密码 - SERVER_SSH_PRIV_KEY # 登陆目标服务器的私钥 - SERVER_ADDR # 目标服务器的地址 预定义的环境变量并不在 .gitlab-ci.yml 中定义，因为它们往往是一些敏感信息，具体的设置方式是提前在 GitLab Web 端代码仓库设置页面填写：Settings &gt; CI/CD &gt; Variables。 参考链接 GitLab Variables: https://docs.gitlab.com/ee/ci/variables/README.html#variables Using SSH keys with GitLab CI/CD: https://docs.gitlab.com/ee/ci/ssh_keys/README.html Building Docker images with GitLab CI/CD:https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#making-docker-in-docker-builds-faster-with-docker-layer-caching","categories":[{"name":"GitLab CI/CD","slug":"GitLab-CI-CD","permalink":"https://laogen.site/categories/GitLab-CI-CD/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://laogen.site/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"https://laogen.site/tags/gitlab-ci/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://laogen.site/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","permalink":"https://laogen.site/tags/DevOps/"}]},{"title":"GitLab CI 示例：构建 & 测试 Node.js 应用","slug":"gitlab-ci/example-node-js","date":"2018-11-13T16:18:13.000Z","updated":"2018-12-10T14:26:28.529Z","comments":true,"path":"gitlab-ci/example-node-js/","link":"","permalink":"https://laogen.site/gitlab-ci/example-node-js/","excerpt":"通过解释说明一个简单的 Node.js 应用的 Pipeline 示例来介绍 GitLab CI 的工作方式和使用。 其中会重点介绍 GitLab CI 的执行过程，Stage Job 等基础概念，以及缓存策略。","text":"通过解释说明一个简单的 Node.js 应用的 Pipeline 示例来介绍 GitLab CI 的工作方式和使用。 其中会重点介绍 GitLab CI 的执行过程，Stage Job 等基础概念，以及缓存策略。 示例定义下面是一个简单的 Node.js 应用的 pipeline 定义： 123456789101112131415161718192021# .gitlab-ci.ymlstages: - build - testcache: paths: - node_modules/build_job: image: node:10 stage: build script: - npm version - npm installtest_job: image: node:10 stage: test script: - npm run test 解释说明逐一介绍一下这几个字段： stages123stages: - build - test stage 定义了 pipeline 的执行步骤，也就是说 stages 是有序执行的。每个 stages 可包括多个 Job，Job 才是 CI Runner 要执行的任务。 上面的 pipeline 包括 build 和 test 两个步骤，先执行完所有 build 阶段的 Job，才会执行 test 阶段的 Job。 如果 build 阶段的 Job 执行失败了，则整个 pipeline 失败并中断执行，不会继续执行 test stage 了。 下面就来介绍什么是 Job. build_job123456build_job: image: node:10 stage: build script: - npm version - npm install build_job 是 Job 的名称，可以自由定义； stage 字段指定该 Job 属于 build 阶段的； script 就是自定义的构建脚本了，这里就是简单的 npm install； image 这个是指定 script 脚本的执行环境，它的值应该是一个 Docker 镜像。 Runner 开始执行这个 Job 时，首先会 pull 项目的最新代码，然后基于这个镜像启动一个容器并把代码挂载到容器里，最后在这个容器里面执行 script 定义的脚本。因为我们这里使用的是 node:10 作为作业的镜像，所以在 script 里才可以直接用 npm。 test_job12345test_job: image: node:10 stage: test script: - npm run test test_job 同样是一个 Job，它属于 test stage，在上面的 stages 定义中 test 是在 build 之后的，所以它会等所有 build 阶段的 Job 执行完之后才会被执行。 重点来了：每个 Job 是独立执行的，互相隔离的。 Runner 在执行 test_job 的时候，会重新 pull 应用的最新代码，然后启动一个新容器并挂载代码，再在里面执行 script 脚本。 这就会导致一个问题： 在 test_job 中我们并没有执行 npm install 就直接执行了 npm run test，理论上会是报错的！ 这就要介绍最后一个未介绍的字段 cache. cache123cache: paths: - node_modules/ cache 是 pipeline 中定义 Job 之间的缓存的； 我们这里定义的 cache 是全局的，即作用于所有 Job 的； paths 定义需要缓存的目录，若需要，你可以指定多个； 缓存的逻辑是这样的： - 执行 build_job 时会检查之前无有缓存 - 如果有缓存就下载到 `paths` 指定的缓存目录，无则忽略 - build_job 执行结束之前，会重新把缓存目录缓存起来 - test_job 执行之前，同样检查有无缓存，有则下载 所以，test_job 的 script 中没有执行 npm install 是因为我们将 node_modules 目录缓存了。 缓存是提高 Job 执行效率的策略，不仅仅是多个 Job 之间； 同一个 Job 在多次 pipeline 中也会共用缓存，意思是： - build_job 第一次运行时并没有缓存 - 下次 pipeline 执行时，npm install 就会基于缓存的 node_modules 更新，而不是全量下载了 总结通过这个示例，基本就了解 GitLab CI 的工作过程和定义方式了； 其中缓存策略是非常常用的，这里使用的是全局缓存，还可以指定某个 Job 特有有缓存策略。 想进一步了解缓存，请查看官方文档关于缓存的详细说明:https://docs.gitlab.com/ee/ci/yaml/README.html#cache 这个简单的示例，只是展示了 Node.js 应用的构建和测试，一个更完整的 CI 流程通常还会包括 部署(deploy)，接下来会继续通过示例讲解使用 GitLab CI 的更多使用。","categories":[{"name":"GitLab CI/CD","slug":"GitLab-CI-CD","permalink":"https://laogen.site/categories/GitLab-CI-CD/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://laogen.site/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"https://laogen.site/tags/gitlab-ci/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://laogen.site/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","permalink":"https://laogen.site/tags/DevOps/"}]},{"title":"GitLab CI 基本介绍","slug":"gitlab-ci/index","date":"2018-11-08T16:03:53.000Z","updated":"2018-12-11T02:16:36.620Z","comments":true,"path":"gitlab-ci/index/","link":"","permalink":"https://laogen.site/gitlab-ci/index/","excerpt":"这篇基本介绍只介绍 GitLab CI，不会写具体的使用细节，旨在让新接触 GitLab CI 的同学先对它有个基本的认识，直接看官网文档可能需要多花点时间才能理清一些概念。 GitLab CI 的设计很灵活，有多种使用方案，我在接下来会针对最常用的几种情况写一系列包括实现细节步骤的文章。","text":"这篇基本介绍只介绍 GitLab CI，不会写具体的使用细节，旨在让新接触 GitLab CI 的同学先对它有个基本的认识，直接看官网文档可能需要多花点时间才能理清一些概念。 GitLab CI 的设计很灵活，有多种使用方案，我在接下来会针对最常用的几种情况写一系列包括实现细节步骤的文章。 前置需求当前有 3 台服务器 develop, staging, production 分别对应代码仓库上的三个分支：develop, staging, master。 要求 push 代码到仓库时会触发 CI 的执行： 1. build app 2. testing app 3. deploy to server 代码 push 到哪个分支，就把项目部署到相应的服务器上。 GitLab CI 的重要概念要理解 GitLab CI 的工作方式，必须要理解两个概念： - Pipeline - Runner 上面说的 CI 执行过程就是 pipeline，它定义了项目的构建、测试、部署等的执行过程。 我们需要在每个项目上定义一个 pipeline。 定义一个 pipeline 就是在项目代码根目录创建文件：.gitlab-ci.yml. 定义好 pipeline 后，GitLab CI 会读取并执行这个 pipeline，执行的程序叫做 Runner。 Runner 是负责执行 pipeline 的程序。 通常 Runner 需要我们自己安装并运行在自己的服务器上，当然也可以使用 gitlab.com 官方提供的免费的 Shared Runner 服务。 GitLab CI 的工作方式 Pipeline 的触发 当开发者 Push 代码到某个分支时，如果我们定义了 Pipeline，也就是代码根目录中有 .gitlab-ci.yml 文件，GitLab 会自动触发 Pipeline 的执行。 Pipeline 的执行 Pipeline 执行时，首先会 pull 下来被触发分支的代码，然后执行你在 pipline 中定义的 Job，Job 是你指定的一些 shell scripts，它就是你构建项目的逻辑。 小结简单介绍一下 GitLab CI 的几个重要概念，接下来会通过实例来详细讲解 GitLab CI 的使用。","categories":[{"name":"GitLab CI/CD","slug":"GitLab-CI-CD","permalink":"https://laogen.site/categories/GitLab-CI-CD/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://laogen.site/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"https://laogen.site/tags/gitlab-ci/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://laogen.site/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","permalink":"https://laogen.site/tags/DevOps/"}]}]}