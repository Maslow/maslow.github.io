{"meta":{"title":"老根's Blog","subtitle":"技术分享与编程感悟","description":null,"author":"Maslow","url":"http://maslow.github.io"},"pages":[{"title":"","date":"2018-11-03T16:58:01.395Z","updated":"2018-11-03T16:58:01.395Z","comments":false,"path":"categories/index.html","permalink":"http://maslow.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-03T16:57:58.708Z","updated":"2018-11-03T16:57:58.708Z","comments":false,"path":"tags/index.html","permalink":"http://maslow.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-03T19:53:56.612Z","updated":"2018-11-03T19:53:56.611Z","comments":true,"path":"downloads/code/app.js","permalink":"http://maslow.github.io/downloads/code/app.js","excerpt":"","text":"const fs = require('fs')"}],"posts":[{"title":"GitLab CI 示例：构建 & 测试 Node.js 应用","slug":"gitlab-ci/example-node-js","date":"2018-11-23T16:18:13.000Z","updated":"2018-11-23T17:24:01.296Z","comments":true,"path":"2018/11/24/gitlab-ci/example-node-js/","link":"","permalink":"http://maslow.github.io/2018/11/24/gitlab-ci/example-node-js/","excerpt":"","text":"示例定义下面是一个简单的 Node.js 应用的 pipeline 定义：123456789101112131415161718192021# .gitlab-ci.ymlstages: - build - testcache: paths: - node_modules/build_job: image: node:10 stage: build script: - npm version - npm installtest_job: image: node:10 stage: test script: - npm run test 解释说明逐一介绍一下这几个字段： stages123stages: - build - test stage 定义了 pipeline 的执行步骤，也就是说 stages 是有序执行的。每个 stages 可包括多个 Job，Job 才是 CI Runner 要执行的任务。 上面的 pipeline 包括 build 和 test 两个步骤，先执行完所有 build 阶段的 Job，才会执行 test 阶段的 Job。 如果 build 阶段的 Job 执行失败了，则整个 pipeline 失败并中断执行，不会继续执行 test stage 了。 下面就来介绍什么是 Job. build_job123456build_job: image: node:10 stage: build script: - npm version - npm install build_job 是 Job 的名称，可以自由定义； stage 字段指定该 Job 属于 build 阶段的； script 就是自定义的构建脚本了，这里就是简单的 npm install； image 这个是指定 script 脚本的执行环境，它的值应该是一个 Docker 镜像。 Runner 开始执行这个 Job 时，首先会 pull 项目的最新代码，然后基于这个镜像启动一个容器并把代码挂载到容器里，最后在这个容器里面执行 script 定义的脚本。因为我们这里使用的是 node:10 作为作业的镜像，所以在 script 里才可以直接用 npm。 test_job12345test_job: image: node:10 stage: test script: - npm run test test_job 同样是一个 Job，它属于 test stage，在上面的 stages 定义中 test 是在 build 之后的，所以它会等所有 build 阶段的 Job 执行完之后才会被执行。 重点来了：每个 Job 是独立执行的，互相隔离的。 Runner 在执行 test_job 的时候，会重新 pull 应用的最新代码，然后启动一个新容器并挂载代码，再在里面执行 script 脚本。 这就会导致一个问题： 在 test_job 中我们并没有执行 npm install 就直接执行了 npm run test，理论上会是报错的！ 这就要介绍最后一个未介绍的字段 cache. cache123cache: paths: - node_modules/ cache 是 pipeline 中定义 Job 之间的缓存的； 我们这里定义的 cache 是全局的，即作用于所有 Job 的； paths 定义需要缓存的目录，若需要，你可以指定多个； 缓存的逻辑是这样的： - 执行 build_job 时会检查之前无有缓存 - 如果有缓存就下载到 `paths` 指定的缓存目录，无则忽略 - build_job 执行结束之前，会重新把缓存目录缓存起来 - test_job 执行之前，同样检查有无缓存，有则下载 所以，test_job 的 script 中没有执行 npm install 是因为我们将 node_modules 目录缓存了。 缓存是提高 Job 执行效率的策略，不仅仅是多个 Job 之间； 同一个 Job 在多次 pipeline 中也会共用缓存，意思是： - build_job 第一次运行时并没有缓存 - 下次 pipeline 执行时，npm install 就会基于缓存的 node_modules 更新，而不是全量下载了 总结通过这个示例，基本就了解 GitLab CI 的工作过程和定义方式了； 其中缓存策略是非常常用的，这里使用的是全局缓存，还可以指定某个 Job 特有有缓存策略。 想进一步了解缓存，请查看官方文档关于缓存的详细说明:https://docs.gitlab.com/ee/ci/yaml/README.html#cache 这个简单的示例，只是展示了 Node.js 应用的构建和测试，一个更完整的 CI 流程通常还会包括 部署(deploy)，接下来会继续通过示例讲解使用 GitLab CI 的更多使用。","categories":[{"name":"基于 GitLab CI 的 DevOps","slug":"基于-GitLab-CI-的-DevOps","permalink":"http://maslow.github.io/categories/基于-GitLab-CI-的-DevOps/"},{"name":"GitLab CI Examples","slug":"基于-GitLab-CI-的-DevOps/GitLab-CI-Examples","permalink":"http://maslow.github.io/categories/基于-GitLab-CI-的-DevOps/GitLab-CI-Examples/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://maslow.github.io/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"http://maslow.github.io/tags/gitlab-ci/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://maslow.github.io/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","permalink":"http://maslow.github.io/tags/DevOps/"}]},{"title":"GitLab CI 基本介绍","slug":"gitlab-ci/index","date":"2018-11-08T16:03:53.000Z","updated":"2018-11-23T17:28:34.081Z","comments":true,"path":"2018/11/09/gitlab-ci/index/","link":"","permalink":"http://maslow.github.io/2018/11/09/gitlab-ci/index/","excerpt":"","text":"目前公司的代码是直接托管在 gitlab.com 上的，就直接采取了 GitLab 提供的 CI 方案。 这篇基本介绍只介绍 GitLab CI，不会写具体的使用细节，旨在让新接触 GitLab CI 的同学先对它有个基本的认识，直接看官网文档可能需要多花点时间才能理清一些概念。 GitLab CI 的设计很灵活，有多种使用方案，我在接下来会针对最常用的几种情况写一系列包括实现细节步骤的文章。 需求当前有 3 台服务器 develop, staging, production 分别对应代码仓库上的三个分支：develop, staging, master。 要求 push 代码到仓库时会触发 CI 的执行： 1. build docker image &amp; push docker image to registry 2. testing 3. deploy to server 代码 push 到哪个分支，就把项目部署到相应的服务器上。 GitLab CI 的重要概念要理解 GitLab CI 的工作方式，必须要理解两个概念： - Pipeline - Runner 上面说的 CI 执行过程就是 pipeline，它定义了项目的构建、测试、部署等的执行过程。 我们需要在每个项目上定义一个 pipeline。 定义一个 pipeline 就是在项目代码根目录创建文件：.gitlab-ci.yml. 定义好 pipeline 后，GitLab CI 会读取并执行这个 pipeline，执行的程序叫做 Runner。 Runner 是负责执行 pipeline 的程序。 通常 Runner 需要我们自己安装并运行在自己的服务器上，当然也可以使用 gitlab.com 官方提供的免费的 Shared Runner 服务。 GitLab CI 的工作方式 Pipeline 的触发当开发者 Push 代码到某个分支时，如果我们定义了 Pipeline，也就是代码根目录中有 .gitlab-ci.yml 文件，GitLab 会自动触发 Pipeline 的执行。 Pipeline 的执行Pipeline 执行时，首先会 pull 下来被触发分支的代码，然后执行你在 pipline 中定义的 Job，Job 是你指定的一些 shell scripts，它就是你构建项目的逻辑。 小结简单介绍一下 GitLab CI 的几个重要概念，接下来会通过实例来详细讲解 GitLab CI 的使用。","categories":[{"name":"基于 GitLab CI 的 DevOps","slug":"基于-GitLab-CI-的-DevOps","permalink":"http://maslow.github.io/categories/基于-GitLab-CI-的-DevOps/"},{"name":"GitLab CI 基本介绍","slug":"基于-GitLab-CI-的-DevOps/GitLab-CI-基本介绍","permalink":"http://maslow.github.io/categories/基于-GitLab-CI-的-DevOps/GitLab-CI-基本介绍/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://maslow.github.io/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"http://maslow.github.io/tags/gitlab-ci/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://maslow.github.io/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","permalink":"http://maslow.github.io/tags/DevOps/"}]}]}